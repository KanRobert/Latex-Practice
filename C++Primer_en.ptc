\contentsline {chapter}{\numberline {1}Getting Started}{1}
\ttl@starttoc {default@1}
\contentsline {section}{\numberline {1.1}Writing a Simple C++ Program}{2}
\contentsline {subsection}{\numberline {1.1.1}Compiling and Executing Our Program}{3}
\contentsline {paragraph}{Program Source File Naming Convention}{3}
\contentsline {paragraph}{Running the Compiler from the Command Line}{3}
\contentsline {section}{\numberline {1.2}A First Look at Input/Output}{4}
\contentsline {paragraph}{Standard Input and Output Objects}{4}
\contentsline {paragraph}{A Program That Uses the IO Library}{4}
\contentsline {paragraph}{Writing to a Stream}{5}
\contentsline {paragraph}{Using Names from the Standard Library}{6}
\contentsline {paragraph}{Reading from a Stream}{6}
\contentsline {paragraph}{Completing the Program}{6}
\contentsline {section}{\numberline {1.3}A Word about Comments}{7}
\contentsline {paragraph}{Kinds of Comments in C++}{7}
\contentsline {paragraph}{Comment Pairs Do Not Nest}{7}
\contentsline {section}{\numberline {1.4}Flow of Control}{8}
\contentsline {subsection}{\numberline {1.4.1}The while Statement}{8}
\contentsline {subsection}{\numberline {1.4.2}The for Statement}{9}
\contentsline {subsection}{\numberline {1.4.3}Reading an Unknown Number of Inputs}{10}
\contentsline {subsection}{\numberline {1.4.4}The if Statement}{12}
\contentsline {section}{\numberline {1.5}Introducing Classes}{14}
\contentsline {subsection}{\numberline {1.5.1}The Sales\_item Class}{14}
\contentsline {paragraph}{Reading and Writing Sales\_items}{15}
\contentsline {paragraph}{Adding Sales\_items}{15}
\contentsline {subsection}{\numberline {1.5.2}A First Look at Member Functions}{16}
\contentsline {paragraph}{What Is a Member Function?}{17}
\contentsline {section}{\numberline {1.6}The Bookstore Program}{17}
\contentsline {section}{Chapter Summary}{19}
\contentsline {section}{Defined Terms}{19}
\ttl@stoptoc {default@1}
\contentsline {part}{I\hspace {1em}The Basics}{22}
\ttl@starttoc {parts@1}
\contentsline {chapter}{\numberline {2}Variables and Basic Types}{24}
\ttl@stoptoc {default@1}
\ttl@starttoc {default@2}
\contentsline {section}{\numberline {2.1}Primitive Built-in Types}{25}
\contentsline {subsection}{\numberline {2.1.1}Arithmetic Types}{25}
\contentsline {paragraph}{Signed and Unsigned Types}{26}
\contentsline {subsection}{\numberline {2.1.2}Type Conversions}{27}
\contentsline {paragraph}{Expressions Involving Unsigned Types}{28}
\contentsline {subsection}{\numberline {2.1.3}Literals}{29}
\contentsline {paragraph}{Integer and Floating-Point Literals}{29}
\contentsline {paragraph}{Character and Character String Literals}{30}
\contentsline {paragraph}{Escape Sequences}{30}
\contentsline {paragraph}{Specifying the Type of a Literal}{31}
\contentsline {paragraph}{Boolean and Pointer Literals}{31}
\contentsline {section}{\numberline {2.2}Variables}{32}
\contentsline {subsection}{\numberline {2.2.1}Variable Definitions}{32}
\contentsline {paragraph}{Initializers}{33}
\contentsline {paragraph}{List Initialization}{33}
\contentsline {paragraph}{Default Initialization}{34}
\contentsline {subsection}{\numberline {2.2.2}Variable Declarations and Definitions}{35}
\contentsline {subsection}{\numberline {2.2.3}Identifiers}{36}
\contentsline {paragraph}{Conventions for Variable Names}{36}
\contentsline {subsection}{\numberline {2.2.4}Scope of a Name}{37}
\contentsline {paragraph}{Nested Scopes}{37}
\contentsline {section}{\numberline {2.3}Compound Types}{38}
\contentsline {subsection}{\numberline {2.3.1}References}{39}
\contentsline {paragraph}{A Reference Is an Alias}{39}
\contentsline {paragraph}{Reference Definitions}{39}
\contentsline {subsection}{\numberline {2.3.2}Pointers}{40}
\contentsline {paragraph}{Taking the Address of an Object}{40}
\contentsline {paragraph}{Pointer Value}{41}
\contentsline {paragraph}{Using a Pointer to Access an Object}{41}
\contentsline {paragraph}{Null Pointers}{41}
\contentsline {paragraph}{Assignment and Pointers}{42}
\contentsline {paragraph}{Other Pointer Operations}{43}
\contentsline {paragraph}{void* Pointers}{43}
\contentsline {subsection}{\numberline {2.3.3}Understanding Compound Type Declarations}{44}
\contentsline {paragraph}{Defining Multiple Variables}{44}
\contentsline {paragraph}{Pointers to Pointers}{45}
\contentsline {paragraph}{References to Pointers}{45}
\contentsline {section}{\numberline {2.4}const Qualifier}{46}
\contentsline {paragraph}{Initialization and const}{46}
\contentsline {paragraph}{By Default, const Objects Are Local to a File}{46}
\contentsline {subsection}{\numberline {2.4.1}References to const}{47}
\contentsline {paragraph}{Initialization and References to const}{47}
\contentsline {paragraph}{A Reference to const May Refer to an Object That Is Not const}{48}
\contentsline {subsection}{\numberline {2.4.2}Pointers and const}{48}
\contentsline {paragraph}{const Pointers}{49}
\contentsline {subsection}{\numberline {2.4.3}Top-Level const}{50}
\contentsline {subsection}{\numberline {2.4.4}constexpr and Constant Expressions}{51}
\contentsline {paragraph}{constexpr Variables}{51}
\contentsline {paragraph}{Literal Types}{52}
\contentsline {paragraph}{Pointers and constexpr}{52}
\contentsline {section}{\numberline {2.5}Dealing with Types}{52}
\contentsline {subsection}{\numberline {2.5.1}Type Aliases}{53}
\contentsline {paragraph}{Pointers, const, and Type Aliases}{53}
\contentsline {subsection}{\numberline {2.5.2}The auto Type Specifier}{53}
\contentsline {paragraph}{Compound Types, const, and auto}{54}
\contentsline {subsection}{\numberline {2.5.3}The decltype Type Specifier}{54}
\contentsline {paragraph}{decltype and References}{55}
\contentsline {section}{\numberline {2.6}Defining Our Own Data Structures}{56}
\contentsline {subsection}{\numberline {2.6.1}Defining the Sales\_data Type}{56}
\contentsline {paragraph}{Class Data Members}{57}
\contentsline {subsection}{\numberline {2.6.2}Using the Sales\_data Type}{57}
\contentsline {paragraph}{Adding Two Sales\_data Objects}{57}
\contentsline {paragraph}{Reading Data into a Sales\_data Object}{58}
\contentsline {paragraph}{Printing the Sum of Two Sales\_data Objects}{58}
\contentsline {subsection}{\numberline {2.6.3}Writing Our Own Header Files}{59}
\contentsline {paragraph}{A Brief Introduction to the Preprocessor}{59}
\contentsline {section}{Chapter Summary}{61}
\contentsline {section}{Defined Terms}{61}
\ttl@stoptoc {default@2}
\contentsline {chapter}{\numberline {3}Strings, Vectors, and Arrays}{64}
\ttl@stoptoc {default@2}
\ttl@starttoc {default@3}
\contentsline {section}{\numberline {3.1}Namespace using Declarations}{65}
\contentsline {paragraph}{A Separate using Declaration Is Required for Each Name}{65}
\contentsline {paragraph}{Headers Should Not Include using Declarations}{66}
\contentsline {paragraph}{A Note to the Reader}{66}
\contentsline {section}{\numberline {3.2}Library \texttt {string} Type}{66}
\contentsline {subsection}{\numberline {3.2.1}Defining and Initializing strings}{66}
\contentsline {paragraph}{Direct and Copy Forms of Initialization}{67}
\contentsline {subsection}{\numberline {3.2.2}Operations on strings}{67}
\contentsline {paragraph}{Reading and Writing strings}{67}
\contentsline {paragraph}{Using getline to Read an Entire Line}{68}
\contentsline {paragraph}{The \texttt {string} \texttt {empty} and \texttt {size} Operations}{68}
\contentsline {paragraph}{The \texttt {string::size\_type} Type}{68}
\contentsline {paragraph}{Comparing \texttt {string}s}{69}
\contentsline {paragraph}{Assignment for strings}{69}
\contentsline {paragraph}{Adding Two strings}{69}
\contentsline {paragraph}{Adding Literals and strings}{70}
\contentsline {subsection}{\numberline {3.2.3}Dealing with the Characters in a string}{70}
\contentsline {paragraph}{Processing Every Character? Use Range-Based for}{71}
\contentsline {paragraph}{Using a Range for to Change the Characters in a string}{72}
\contentsline {paragraph}{Processing Only Some Characters?}{72}
\contentsline {paragraph}{Using a Subscript for Iteration}{73}
\contentsline {paragraph}{Using a Subscript for Random Access}{73}
\contentsline {section}{\numberline {3.3}Library \texttt {vector} Type}{74}
\contentsline {subsection}{\numberline {3.3.1}Defining and Initializing vectors}{75}
\contentsline {paragraph}{List Initializing a vector}{75}
\contentsline {paragraph}{Creating a Specified Number of Elements}{76}
\contentsline {paragraph}{Value Initialization}{76}
\contentsline {paragraph}{List Initializer or Element Count?}{76}
\contentsline {subsection}{\numberline {3.3.2}Adding Elements to a vector}{77}
\contentsline {paragraph}{Programming Implications of Adding Elements to a vector}{78}
\contentsline {subsection}{\numberline {3.3.3}Other vector Operations}{78}
\contentsline {paragraph}{Computing a vector Index}{79}
\contentsline {paragraph}{Subscripting Does Not Add Elements}{80}
\contentsline {section}{\numberline {3.4}Introducing Iterators}{81}
\contentsline {subsection}{\numberline {3.4.1}Using Iterators}{81}
\contentsline {paragraph}{Iterator Operations}{81}
\contentsline {paragraph}{Moving Iterators from One Element to Another}{82}
\contentsline {paragraph}{Iterator Types}{83}
\contentsline {paragraph}{The begin and end Operations}{83}
\contentsline {paragraph}{Combining Dereference and Member Access}{83}
\contentsline {paragraph}{Some vector Operations Invalidate Iterators}{84}
\contentsline {subsection}{\numberline {3.4.2}Iterator Arithmetic}{84}
\contentsline {paragraph}{Arithmetic Operations on Iterators}{85}
\contentsline {paragraph}{Using Iterator Arithmetic}{85}
\contentsline {section}{\numberline {3.5}Arrays}{86}
\contentsline {subsection}{\numberline {3.5.1}Defining and Initializing Built-in Arrays}{86}
\contentsline {paragraph}{Explicitly Initializing Array Elements}{87}
\contentsline {paragraph}{Character Arrays Are Special}{87}
\contentsline {paragraph}{No Copy or Assignment}{87}
\contentsline {paragraph}{Understanding Complicated Array Declarations}{87}
\contentsline {subsection}{\numberline {3.5.2}Accessing the Elements of an Array}{88}
\contentsline {paragraph}{Checking Subscript Values}{89}
\contentsline {subsection}{\numberline {3.5.3}Pointers and Arrays}{89}
\contentsline {paragraph}{Pointers Are Iterators}{90}
\contentsline {paragraph}{The Library begin and end Functions}{90}
\contentsline {paragraph}{Pointer Arithmetic}{91}
\contentsline {paragraph}{Interaction between Dereference and Pointer Arithmetic}{92}
\contentsline {paragraph}{Subscripts and Pointers}{92}
\contentsline {subsection}{\numberline {3.5.4}C-Style Character Strings}{93}
\contentsline {paragraph}{C Library String Functions}{93}
\contentsline {paragraph}{Comparing Strings}{93}
\contentsline {paragraph}{Caller Is Responsible for Size of a Destination String}{94}
\contentsline {subsection}{\numberline {3.5.5}Interfacing to Older Code}{94}
\contentsline {paragraph}{Mixing Library strings and C-Style Strings}{94}
\contentsline {paragraph}{Using an Array to Initialize a vector}{95}
\contentsline {section}{\numberline {3.6}Multidimensional Arrays}{95}
\contentsline {paragraph}{Initializing the Elements of a Multidimensional Array}{96}
\contentsline {paragraph}{Subscripting a Multidimensional Array}{96}
\contentsline {paragraph}{Using a Range for with Multidimensional Arrays}{97}
\contentsline {paragraph}{Pointers and Multidimensional Arrays}{97}
\contentsline {paragraph}{Type Aliases Simplify Pointers to Multidimensional Arrays}{98}
\contentsline {section}{Chapter Summary}{100}
\contentsline {section}{Defined Terms}{100}
\ttl@stoptoc {default@3}
\contentsline {chapter}{\numberline {4}Expressions}{102}
\ttl@stoptoc {default@3}
\ttl@starttoc {default@4}
\contentsline {section}{\numberline {4.1}Fundamentals}{103}
\contentsline {subsection}{\numberline {4.1.1}Basic Concepts}{103}
\contentsline {paragraph}{Grouping Operators and Operands}{103}
\contentsline {paragraph}{Operand Conversions}{103}
\contentsline {paragraph}{Overloaded Operators}{103}
\contentsline {paragraph}{Lvalues and Rvalues}{103}
\contentsline {subsection}{\numberline {4.1.2}Precedence and Associativity}{104}
\contentsline {paragraph}{Parentheses Override Precedence and Associativity}{104}
\contentsline {paragraph}{When Precedence and Associativity Matter}{105}
\contentsline {subsection}{\numberline {4.1.3}Order of Evaluation}{105}
\contentsline {paragraph}{Order of Evaluation, Precedence, and Associativity}{105}
\contentsline {section}{\numberline {4.2}Arithmetic Operators}{106}
\contentsline {section}{\numberline {4.3}Logical and Relational Operators}{108}
\contentsline {paragraph}{Logical AND and OR Operators}{108}
\contentsline {paragraph}{Logical NOT Operator}{109}
\contentsline {paragraph}{The Relational Operators}{109}
\contentsline {paragraph}{Equality Tests and the bool Literals}{109}
\contentsline {section}{\numberline {4.4}Assignment Operators}{110}
\contentsline {paragraph}{Assignment Is Right Associative}{111}
\contentsline {paragraph}{Assignment Has Low Precedence}{111}
\contentsline {paragraph}{Beware of Confusing Equality and Assignment Operators}{111}
\contentsline {paragraph}{Compound Assignment Operators}{112}
\contentsline {section}{\numberline {4.5}Increment and Decrement Operators}{112}
\contentsline {paragraph}{Combining Dereference and Increment in a Single Expression}{113}
\contentsline {paragraph}{Remember That Operands Can Be Evaluated in Any Order}{113}
\contentsline {section}{\numberline {4.6}The Member Access Operators}{114}
\contentsline {section}{\numberline {4.7}The Conditional Operator}{115}
\contentsline {paragraph}{Nesting Conditional Operations}{115}
\contentsline {paragraph}{Using a Conditional Operator in an Output Expression}{115}
\contentsline {section}{\numberline {4.8}The Bitwise Operators}{116}
\contentsline {paragraph}{Bitwise Shift Operators}{117}
\contentsline {paragraph}{Bitwise NOT Operator}{117}
\contentsline {paragraph}{Bitwise AND, OR, and XOR Operators}{117}
\contentsline {paragraph}{Using Bitwise Operators}{118}
\contentsline {paragraph}{Shift Operators (aka IO Operators) Are Left Associative}{118}
\contentsline {section}{\numberline {4.9}The sizeof Operator}{119}
\contentsline {section}{\numberline {4.10}Comma Operator}{120}
\contentsline {section}{\numberline {4.11}Type Conversions}{121}
\contentsline {paragraph}{When Implicit Conversions Occur}{121}
\contentsline {subsection}{\numberline {4.11.1}The Arithmetic Conversions}{121}
\contentsline {paragraph}{Integral Promotions}{122}
\contentsline {paragraph}{Operands of Unsigned Type}{122}
\contentsline {paragraph}{Understanding the Arithmetic Conversions}{122}
\contentsline {subsection}{\numberline {4.11.2}Other Implicit Conversions}{123}
\contentsline {subsection}{\numberline {4.11.3}Explicit Conversions}{124}
\contentsline {paragraph}{Named Casts}{124}
\contentsline {paragraph}{\texttt {static\_cast}}{124}
\contentsline {paragraph}{\texttt {const\_cast}}{125}
\contentsline {paragraph}{\texttt {reinterpret\_cast}}{125}
\contentsline {paragraph}{Old-Style Casts}{125}
\contentsline {section}{\numberline {4.12}Operator Precedence Table}{126}
\contentsline {section}{Chapter Summary}{128}
\contentsline {section}{Defined Terms}{128}
\ttl@stoptoc {default@4}
\contentsline {chapter}{\numberline {5}Statements}{130}
\ttl@stoptoc {default@4}
\ttl@starttoc {default@5}
\contentsline {section}{\numberline {5.1}Simple Statements}{131}
\contentsline {paragraph}{Null Statements}{131}
\contentsline {paragraph}{Beware of Missing or Extraneous Semicolons}{131}
\contentsline {paragraph}{Compound Statements (Blocks)}{132}
\contentsline {section}{\numberline {5.2}Statement Scope}{132}
\contentsline {section}{\numberline {5.3}Conditional Statements}{133}
\contentsline {subsection}{\numberline {5.3.1}The if Statement}{133}
\contentsline {paragraph}{Using an if else Statement}{133}
\contentsline {paragraph}{Nested if Statements}{134}
\contentsline {paragraph}{Watch Your Braces}{134}
\contentsline {paragraph}{Dangling else}{134}
\contentsline {paragraph}{Controlling the Execution Path with Braces}{135}
\contentsline {subsection}{\numberline {5.3.2}The switch Statement}{136}
\contentsline {paragraph}{Control Flow within a switch}{137}
\contentsline {paragraph}{Forgetting a break Is a Common Source of Bugs}{138}
\contentsline {paragraph}{The default Label}{138}
\contentsline {paragraph}{Variable Definitions inside the Body of a switch}{139}
\contentsline {section}{\numberline {5.4}Iterative Statements}{141}
\contentsline {subsection}{\numberline {5.4.1}The while Statement}{141}
\contentsline {paragraph}{Using a while Loop}{141}
\contentsline {subsection}{\numberline {5.4.2}Traditional for Statement}{141}
\contentsline {paragraph}{Execution Flow in a Traditional for Loop}{142}
\contentsline {paragraph}{Multiple Definitions in the for Header}{142}
\contentsline {paragraph}{Omitting Parts of the for Header}{142}
\contentsline {subsection}{\numberline {5.4.3}Range for Statement}{143}
\contentsline {subsection}{\numberline {5.4.4}The do while Statement}{144}
\contentsline {section}{\numberline {5.5}Jump Statements}{145}
\contentsline {subsection}{\numberline {5.5.1}The break Statement}{145}
\contentsline {subsection}{\numberline {5.5.2}The continue Statement}{146}
\contentsline {subsection}{\numberline {5.5.3}The goto Statement}{146}
\contentsline {section}{\numberline {5.6}try Blocks and Exception Handling}{147}
\contentsline {subsection}{\numberline {5.6.1}A throw Expression}{147}
\contentsline {subsection}{\numberline {5.6.2}The try Block}{148}
\contentsline {paragraph}{Writing a Handler}{148}
\contentsline {paragraph}{Functions Are Exited during the Search for a Handler}{149}
\contentsline {subsection}{\numberline {5.6.3}Standard Exceptions}{150}
\contentsline {section}{Chapter Summary}{152}
\contentsline {section}{Defined Terms}{152}
\ttl@stoptoc {default@5}
\contentsline {chapter}{\numberline {6}Functions}{154}
\ttl@stoptoc {default@5}
\ttl@starttoc {default@6}
\contentsline {section}{\numberline {6.1}Function Basics}{155}
\contentsline {paragraph}{Writing a Function}{155}
\contentsline {paragraph}{Calling a Function}{155}
\contentsline {paragraph}{Parameters and Arguments}{156}
\contentsline {paragraph}{Function Parameter List}{156}
\contentsline {paragraph}{Function Return Type}{156}
\contentsline {subsection}{\numberline {6.1.1}Local Objects}{157}
\contentsline {paragraph}{Automatic Objects}{157}
\contentsline {paragraph}{Local static Objects}{157}
\contentsline {subsection}{\numberline {6.1.2}Function Declarations}{158}
\contentsline {paragraph}{Function Declarations Go in Header Files}{158}
\contentsline {subsection}{\numberline {6.1.3}Separate Compilation}{159}
\contentsline {paragraph}{Compiling and Linking Multiple Source Files}{159}
\contentsline {section}{\numberline {6.2}Argument Passing}{159}
\contentsline {subsection}{\numberline {6.2.1}Passing Arguments by Value}{160}
\contentsline {paragraph}{Pointer Parameters}{160}
\contentsline {subsection}{\numberline {6.2.2}Passing Arguments by Reference}{160}
\contentsline {paragraph}{Using References to Avoid Copies}{161}
\contentsline {paragraph}{Using Reference Parameters to Return Additional Information}{161}
\contentsline {subsection}{\numberline {6.2.3}const Parameters and Arguments}{162}
\contentsline {paragraph}{Pointer or Reference Parameters and const}{162}
\contentsline {paragraph}{Use Reference to const When Possible}{163}
\contentsline {subsection}{\numberline {6.2.4}Array Parameters}{164}
\contentsline {paragraph}{Using a Marker to Specify the Extent of an Array}{165}
\contentsline {paragraph}{Using the Standard Library Conventions}{165}
\contentsline {paragraph}{Explicitly Passing a Size Parameter}{165}
\contentsline {paragraph}{Array Parameters and const}{166}
\contentsline {paragraph}{Array Reference Parameters}{166}
\contentsline {paragraph}{Passing a Multidimensional Array}{166}
\contentsline {subsection}{\numberline {6.2.5}\texttt {main}: Handling Command-Line Options}{167}
\contentsline {subsection}{\numberline {6.2.6}Functions with Varying Parameters}{168}
\contentsline {paragraph}{initializer\texttt {\_}list Parameters}{168}
\contentsline {paragraph}{Ellipsis Parameters}{169}
\contentsline {section}{\numberline {6.3}Return Types and the return Statement}{170}
\contentsline {subsection}{\numberline {6.3.1}Functions with No Return Value}{170}
\contentsline {subsection}{\numberline {6.3.2}Functions That Return a Value}{170}
\contentsline {paragraph}{How Values Are Returned}{171}
\contentsline {paragraph}{Never Return a Reference or Pointer to a Local Object}{171}
\contentsline {paragraph}{Functions That Return Class Types and the Call Operator}{172}
\contentsline {paragraph}{Reference Returns Are Lvalues}{172}
\contentsline {paragraph}{List Initializing the Return Value}{172}
\contentsline {paragraph}{Return from main}{173}
\contentsline {paragraph}{Recursion}{173}
\contentsline {subsection}{\numberline {6.3.3}Returning a Pointer to an Array}{174}
\contentsline {paragraph}{Declaring a Function That Returns a Pointer to an Array}{174}
\contentsline {paragraph}{Using a Trailing Return Type}{175}
\contentsline {paragraph}{Using decltype}{175}
\contentsline {section}{\numberline {6.4}Overloaded Functions}{175}
\contentsline {paragraph}{Defining Overloaded Functions}{176}
\contentsline {paragraph}{Determining Whether Two Parameter Types Differ}{176}
\contentsline {paragraph}{Overloading and const Parameters}{176}
\contentsline {paragraph}{\texttt {const\_cast} and Overloading}{177}
\contentsline {paragraph}{Calling an Overloaded Function}{178}
\contentsline {subsection}{\numberline {6.4.1}Overloading and Scope}{178}
\contentsline {section}{\numberline {6.5}Features for Specialized Uses}{179}
\contentsline {subsection}{\numberline {6.5.1}Default Arguments}{179}
\contentsline {paragraph}{Calling Functions with Default Arguments}{179}
\contentsline {paragraph}{Default Argument Declarations}{180}
\contentsline {paragraph}{Default Argument Initializers}{180}
\contentsline {subsection}{\numberline {6.5.2}Inline and constexpr Functions}{181}
\contentsline {paragraph}{inline Functions Avoid Function Call Overhead}{181}
\contentsline {paragraph}{constexpr Functions}{182}
\contentsline {paragraph}{Put inline and constexpr Functions in Header Files}{182}
\contentsline {subsection}{\numberline {6.5.3}Aids for Debugging}{183}
\contentsline {paragraph}{The assert Preprocessor Macro}{183}
\contentsline {paragraph}{The NDEBUG Preprocessor Variable}{183}
\contentsline {section}{\numberline {6.6}Function Matching}{184}
\contentsline {paragraph}{Determining the Candidate and Viable Functions}{185}
\contentsline {paragraph}{Finding the Best Match, If Any}{185}
\contentsline {paragraph}{Function Matching with Multiple Parameters}{185}
\contentsline {subsection}{\numberline {6.6.1}Argument Type Conversions}{186}
\contentsline {paragraph}{Matches Requiring Promotion or Arithmetic Conversion}{186}
\contentsline {paragraph}{Function Matching and const Arguments}{187}
\contentsline {section}{\numberline {6.7}Pointers to Functions}{188}
\contentsline {paragraph}{Using Function Pointers}{188}
\contentsline {paragraph}{Pointers to Overloaded Functions}{189}
\contentsline {paragraph}{Function Pointer Parameters}{189}
\contentsline {paragraph}{Returning a Pointer to Function}{190}
\contentsline {paragraph}{Using auto or decltype for Function Pointer Types}{190}
\contentsline {section}{Chapter Summary}{191}
\contentsline {section}{Defined Terms}{191}
\ttl@stoptoc {default@6}
\contentsline {chapter}{\numberline {7}Classes}{193}
\ttl@stoptoc {default@6}
\ttl@starttoc {default@7}
\contentsline {section}{\numberline {7.1}Defining Abstract Data Types}{194}
\contentsline {subsection}{\numberline {7.1.1}Designing the Sales\_data Class}{194}
\contentsline {paragraph}{Using the Revised Sales\_data Class}{195}
\contentsline {subsection}{\numberline {7.1.2}Designing the revised Sales\_data Class}{195}
\contentsline {paragraph}{Defining Member Functions}{196}
\contentsline {paragraph}{Introducing this}{196}
\contentsline {paragraph}{Introducing \texttt {const} Member Functions}{197}
\contentsline {paragraph}{Class Scope and Member Functions}{197}
\contentsline {paragraph}{Defining a Member Function outside the Class}{197}
\contentsline {paragraph}{Defining a Function to Return “This” Object}{198}
\contentsline {subsection}{\numberline {7.1.3}Defining Nonmember Class-Related Functions}{198}
\contentsline {paragraph}{Defining the read and print Functions}{199}
\contentsline {paragraph}{Defining the add Function}{199}
\contentsline {subsection}{\numberline {7.1.4}Constructors}{199}
\contentsline {paragraph}{The Synthesized Default Constructor}{200}
\contentsline {paragraph}{Some Classes Cannot Rely on the Synthesized Default Constructor}{200}
\contentsline {paragraph}{Defining the \texttt {Sales\_data} Constructors}{201}
\contentsline {paragraph}{What \texttt {=} default Means}{201}
\contentsline {paragraph}{Constructor Initializer List}{201}
\contentsline {paragraph}{Defining a Constructor outside the Class Body}{202}
\contentsline {subsection}{\numberline {7.1.5}Copy, Assignment, and Destruction}{203}
\contentsline {paragraph}{Some Classes Cannot Rely on the Synthesized Versions}{203}
\contentsline {section}{\numberline {7.2}Access Control and Encapsulation}{203}
\contentsline {paragraph}{Using the class or struct Keyword}{204}
\contentsline {subsection}{\numberline {7.2.1}Friends}{204}
\contentsline {paragraph}{Declarations for Friends}{205}
\contentsline {section}{\numberline {7.3}Additional Class Features}{206}
\contentsline {subsection}{\numberline {7.3.1}Class Members Revisited}{206}
\contentsline {paragraph}{Defining a Type Member}{206}
\contentsline {paragraph}{Member Functions of class Screen}{207}
\contentsline {paragraph}{Making Members inline}{207}
\contentsline {paragraph}{Overloading Member Functions}{208}
\contentsline {paragraph}{mutable Data Members}{208}
\contentsline {paragraph}{Initializers for Data Members of Class Type}{208}
\contentsline {subsection}{\numberline {7.3.2}Functions That Return *this}{209}
\contentsline {paragraph}{Returning \texttt {*}this from a const Member Function}{209}
\contentsline {paragraph}{Overloading Based on const}{210}
\contentsline {subsection}{\numberline {7.3.3}Class Types}{211}
\contentsline {paragraph}{Class Declarations}{212}
\contentsline {subsection}{\numberline {7.3.4}Friendship Revisited}{212}
\contentsline {paragraph}{Friendship between Classes}{212}
\contentsline {paragraph}{Making A Member Function a Friend}{213}
\contentsline {paragraph}{Overloaded Functions and Friendship}{213}
\contentsline {paragraph}{Friend Declarations and Scope}{214}
\contentsline {section}{\numberline {7.4}Class Scope}{214}
\contentsline {paragraph}{Scope and Members Defined outside the Class}{214}
\contentsline {subsection}{\numberline {7.4.1}Name Lookup and Class Scope}{215}
\contentsline {paragraph}{Name Lookup for Class Member Declarations}{216}
\contentsline {paragraph}{Type Names Are Special}{216}
\contentsline {paragraph}{Normal Block-Scope Name Lookup inside Member Definitions}{216}
\contentsline {paragraph}{After Class Scope, Look in the Surrounding Scope}{217}
\contentsline {paragraph}{Names Are Resolved Where They Appear within a File}{218}
\contentsline {section}{\numberline {7.5}Constructors Revisited}{218}
\contentsline {subsection}{\numberline {7.5.1}Constructor Initializer List}{219}
\contentsline {paragraph}{Constructor Initializers Are Sometimes Required}{219}
\contentsline {paragraph}{Order of Member Initialization}{220}
\contentsline {paragraph}{Default Arguments and Constructors}{220}
\contentsline {subsection}{\numberline {7.5.2}Delegating Constructors}{221}
\contentsline {subsection}{\numberline {7.5.3}The Role of the Default Constructor}{222}
\contentsline {paragraph}{Using the Default Constructor}{223}
\contentsline {subsection}{\numberline {7.5.4}Implicit Class-Type Conversions}{224}
\contentsline {paragraph}{Only One Class-Type Conversion Is Allowed}{224}
\contentsline {paragraph}{Class-Type Conversions Are Not Always Useful}{224}
\contentsline {paragraph}{Suppressing Implicit Conversions Defined by Constructors}{224}
\contentsline {paragraph}{explicit Constructors Can Be Used Only for Direct Initialization}{225}
\contentsline {paragraph}{Explicitly Using Constructors for Conversions}{225}
\contentsline {paragraph}{Library Classes with explicit Constructors}{225}
\contentsline {subsection}{\numberline {7.5.5}Aggregate Classes}{226}
\contentsline {subsection}{\numberline {7.5.6}Literal Classes}{227}
\contentsline {paragraph}{constexpr Constructors}{227}
\contentsline {section}{\numberline {7.6}static Class Members}{228}
\contentsline {paragraph}{Declaring static Members}{228}
\contentsline {paragraph}{Using a Class static Member}{228}
\contentsline {paragraph}{Defining static Members}{229}
\contentsline {paragraph}{In-Class Initialization of static Data Members}{229}
\contentsline {paragraph}{static Members Can Be Used in Ways Ordinary Members Can’t}{230}
\contentsline {section}{Chapter Summary}{232}
\contentsline {section}{Defined Terms}{232}
\ttl@stoptoc {default@7}
\ttl@stoptoc {parts@1}
\contentsline {part}{II\hspace {1em}The C++ Library}{234}
\ttl@stoptoc {parts@1}
\ttl@starttoc {parts@2}
\contentsline {chapter}{\numberline {8}The IO Library}{235}
\ttl@stoptoc {default@7}
\ttl@starttoc {default@8}
\contentsline {section}{\numberline {8.1}The IO Classes}{236}
\contentsline {paragraph}{Relationships among the IO Types}{236}
\contentsline {subsection}{\numberline {8.1.1}No Copy or Assign for IO Objects}{237}
\contentsline {subsection}{\numberline {8.1.2}Condition States}{237}
\contentsline {paragraph}{Interrogating the State of a Stream}{238}
\contentsline {paragraph}{Managing the Condition State}{239}
\contentsline {subsection}{\numberline {8.1.3}Managing the Output Buffer}{240}
\contentsline {paragraph}{Flushing the Output Buffer}{240}
\contentsline {paragraph}{The unitbuf Manipulator}{240}
\contentsline {paragraph}{Tying Input and Output Streams Together}{240}
\contentsline {section}{\numberline {8.2}File Input and Output}{241}
\contentsline {subsection}{\numberline {8.2.1}Using File Stream Objects}{242}
\contentsline {paragraph}{Using an fstream in Place of an iostream\texttt {\&}}{242}
\contentsline {paragraph}{The open and close Members}{243}
\contentsline {paragraph}{Automatic Construction and Destruction}{243}
\contentsline {subsection}{\numberline {8.2.2}File Modes}{244}
\contentsline {paragraph}{Opening a File in out Mode Discards Existing Data}{244}
\contentsline {paragraph}{File Mode Is Determined Each Time open Is Called}{245}
\contentsline {section}{\numberline {8.3}string Streams}{245}
\contentsline {subsection}{\numberline {8.3.1}Using an istringstream}{245}
\contentsline {subsection}{\numberline {8.3.2}Using ostringstreams}{246}
\contentsline {section}{Chapter Summary}{248}
\contentsline {section}{Defined Terms}{248}
\ttl@stoptoc {default@8}
\contentsline {chapter}{\numberline {9}Sequential Containers}{249}
\ttl@stoptoc {default@8}
\ttl@starttoc {default@9}
\contentsline {section}{\numberline {9.1}Overview of the Sequential Containers}{250}
\contentsline {paragraph}{Deciding Which Sequential Container to Use}{251}
\contentsline {section}{\numberline {9.2}Container Library Overview}{252}
\contentsline {paragraph}{Constraints on Types That a Container Can Hold}{253}
\contentsline {subsection}{\numberline {9.2.1}Iterators}{253}
\contentsline {paragraph}{Iterator Ranges}{253}
\contentsline {paragraph}{Programming Implications of Using Left-Inclusive Ranges}{254}
\contentsline {subsection}{\numberline {9.2.2}Container Type Members}{255}
\contentsline {subsection}{\numberline {9.2.3}begin and end Members}{255}
\contentsline {subsection}{\numberline {9.2.4}Defining and Initializing a Container}{256}
\contentsline {paragraph}{Initializing a Container as a Copy of Another Container}{256}
\contentsline {paragraph}{List Initialization}{257}
\contentsline {paragraph}{Sequential Container Size-Related Constructors}{257}
\contentsline {paragraph}{Library \texttt {array}s Have Fixed Size}{257}
\contentsline {subsection}{\numberline {9.2.5}Assignment and swap}{258}
\contentsline {paragraph}{Using \texttt {assign} (Sequential Containers Only)}{259}
\contentsline {paragraph}{Using swap}{259}
\contentsline {subsection}{\numberline {9.2.6}Container Size Operations}{260}
\contentsline {subsection}{\numberline {9.2.7}Relational Operators}{260}
\contentsline {paragraph}{Relational Operators Use Their Element’s Relational Operator}{260}
\contentsline {section}{\numberline {9.3}Sequential Container Operations}{261}
\contentsline {subsection}{\numberline {9.3.1}Adding Elements to a Sequential Container}{261}
\contentsline {paragraph}{Using \texttt {push\_back}}{262}
\contentsline {paragraph}{Using \texttt {push\_front}}{262}
\contentsline {paragraph}{Adding Elements at a Specified Point in the Container}{262}
\contentsline {paragraph}{Inserting a Range of Elements}{263}
\contentsline {paragraph}{Using the Return from insert}{263}
\contentsline {paragraph}{Using the Emplace Operations}{264}
\contentsline {subsection}{\numberline {9.3.2}Accessing Elements}{265}
\contentsline {subsection}{\numberline {9.3.3}Erasing Elements}{265}
\contentsline {subsection}{\numberline {9.3.4}Specialized \texttt {forward\_list} Operations}{265}
\contentsline {subsection}{\numberline {9.3.5}Resizing a Container}{265}
\contentsline {subsection}{\numberline {9.3.6}Container Operations May Invalidate Iterators}{265}
\contentsline {section}{\numberline {9.4}How a vector Grows}{265}
\contentsline {section}{\numberline {9.5}Additional string Operations}{265}
\contentsline {subsection}{\numberline {9.5.1}Other Ways to Construct strings}{265}
\contentsline {subsection}{\numberline {9.5.2}Other Ways to Change a string}{265}
\contentsline {subsection}{\numberline {9.5.3}string Search Operations}{265}
\contentsline {subsection}{\numberline {9.5.4}The compare Functions}{265}
\contentsline {subsection}{\numberline {9.5.5}Numeric Conversions}{265}
\contentsline {section}{\numberline {9.6}Container Adaptors}{265}
\contentsline {section}{Chapter Summary}{266}
\contentsline {section}{Defined Terms}{266}
\ttl@stoptoc {default@9}
\contentsline {chapter}{\numberline {10}Generic Algorithms}{267}
\ttl@stoptoc {default@9}
\ttl@starttoc {default@10}
\contentsline {section}{\numberline {10.1}Overview}{268}
\contentsline {section}{\numberline {10.2}A First Look at the Algorithms}{268}
\contentsline {subsection}{\numberline {10.2.1}Read-Only Algorithms}{268}
\contentsline {subsection}{\numberline {10.2.2}Algorithms That Write Container Elements}{268}
\contentsline {subsection}{\numberline {10.2.3}Algorithms That Reorder Container Elements}{268}
\contentsline {section}{\numberline {10.3}Customizing Operations}{268}
\contentsline {subsection}{\numberline {10.3.1}Passing a Function to an Algorithm}{268}
\contentsline {subsection}{\numberline {10.3.2}Lambda Expressions}{268}
\contentsline {subsection}{\numberline {10.3.3}Lambda Captures and Returns}{268}
\contentsline {subsection}{\numberline {10.3.4}Binding Arguments}{268}
\contentsline {section}{\numberline {10.4}Revisiting Iterators}{268}
\contentsline {subsection}{\numberline {10.4.1}Insert Iterators}{268}
\contentsline {subsection}{\numberline {10.4.2}iostream Iterators}{268}
\contentsline {subsection}{\numberline {10.4.3}Reverse Iterators}{268}
\contentsline {section}{\numberline {10.5}Structure of Generic Algorithms}{268}
\contentsline {subsection}{\numberline {10.5.1}The Five Iterator Categories}{268}
\contentsline {subsection}{\numberline {10.5.2}Algorithm Parameter Patterns}{268}
\contentsline {subsection}{\numberline {10.5.3}Algorithm Naming Conventions}{268}
\contentsline {section}{\numberline {10.6}Container-Specific Algorithms}{268}
\contentsline {section}{Chapter Summary}{269}
\contentsline {section}{Defined Terms}{269}
\ttl@stoptoc {default@10}
\contentsline {chapter}{\numberline {11}Associative Containers}{270}
\ttl@stoptoc {default@10}
\ttl@starttoc {default@11}
\contentsline {section}{\numberline {11.1}Using an Associative Container}{270}
\contentsline {section}{\numberline {11.2}Overview of the Associative Containers}{270}
\contentsline {subsection}{\numberline {11.2.1}Defining an Associative Container}{270}
\contentsline {paragraph}{Initializing a multimap or multiset}{270}
\contentsline {subsection}{\numberline {11.2.2}Requirements on Key Type}{270}
\contentsline {paragraph}{Key Types for Ordered Containers}{270}
\contentsline {paragraph}{Using a Comparison Function for the Key Type}{270}
\contentsline {subsection}{\numberline {11.2.3}The pair Type}{270}
\contentsline {section}{\numberline {11.3}Operations on Associative Containers}{270}
\contentsline {subsection}{\numberline {11.3.1}Associative Container Iterators}{270}
\contentsline {subsection}{\numberline {11.3.2}Adding Elements}{270}
\contentsline {subsection}{\numberline {11.3.3}Erasing Elements}{270}
\contentsline {subsection}{\numberline {11.3.4}Subscripting a map}{270}
\contentsline {subsection}{\numberline {11.3.5}Accessing Elements}{270}
\contentsline {subsection}{\numberline {11.3.6}A Word Transformation Map}{271}
\contentsline {section}{\numberline {11.4}The Unordered Containers}{271}
\contentsline {paragraph}{Using an Unordered Container}{271}
\contentsline {paragraph}{Managing the Buckets}{271}
\contentsline {paragraph}{Requirements on Key Type for Unordered Containers}{271}
\contentsline {section}{Chapter Summary}{272}
\contentsline {section}{Defined Terms}{272}
\ttl@stoptoc {default@11}
\contentsline {chapter}{\numberline {12}Dynamic Memory}{273}
\ttl@stoptoc {default@11}
\ttl@starttoc {default@12}
\contentsline {section}{\numberline {12.1}Dynamic Memory and Smart Pointers}{274}
\contentsline {subsection}{\numberline {12.1.1}The shared\texttt {\_}ptr Class}{274}
\contentsline {subsection}{\numberline {12.1.2}Managing Memory Directly}{274}
\contentsline {paragraph}{Using new to Dynamically Allocate and Initialize Objects}{274}
\contentsline {paragraph}{Dynamically Allocated const Objects}{274}
\contentsline {paragraph}{Memory Exhaustion}{274}
\contentsline {paragraph}{Freeing Dynamic Memory}{274}
\contentsline {paragraph}{Pointer Values and delete}{274}
\contentsline {paragraph}{Dynamically Allocated Objects Exist until They Are Freed}{274}
\contentsline {paragraph}{Resetting the Value of a Pointer after a delete ...}{274}
\contentsline {paragraph}{...Provides Only Limited Protection}{274}
\contentsline {subsection}{\numberline {12.1.3}Using shared\texttt {\_}ptr with new}{274}
\contentsline {subsection}{\numberline {12.1.4}Smart Pointers and Exceptions}{274}
\contentsline {subsection}{\numberline {12.1.5}unique\texttt {\_}ptr}{274}
\contentsline {subsection}{\numberline {12.1.6}weak\texttt {\_}ptr}{274}
\contentsline {section}{\numberline {12.2}Dynamic Arrays}{274}
\contentsline {subsection}{\numberline {12.2.1}new and Arrays}{274}
\contentsline {subsection}{\numberline {12.2.2}The allocator Class}{274}
\contentsline {section}{\numberline {12.3}Using the Library: A Text-Query Program}{274}
\contentsline {subsection}{\numberline {12.3.1}Design of the Query Program}{274}
\contentsline {subsection}{\numberline {12.3.2}Defining the Query Program Classes}{274}
\contentsline {section}{Chapter Summary}{275}
\contentsline {section}{Defined Terms}{275}
\ttl@stoptoc {default@12}
\contentsline {part}{III\hspace {1em}Tools for Class Authors}{276}
\ttl@stoptoc {parts@2}
\ttl@starttoc {parts@3}
\contentsline {chapter}{\numberline {13}Copy Control}{277}
\ttl@stoptoc {default@12}
\ttl@starttoc {default@13}
\contentsline {section}{\numberline {13.1}Copy, Assign, and Destroy}{278}
\contentsline {subsection}{\numberline {13.1.1}The Copy Constructor}{278}
\contentsline {paragraph}{The Synthesized Copy Constructor}{278}
\contentsline {subsection}{\numberline {13.1.2}The Copy-Assignment Operator}{278}
\contentsline {paragraph}{Introducing Overloaded Assignment}{278}
\contentsline {paragraph}{The Synthesized Copy-Assignment Operator}{278}
\contentsline {subsection}{\numberline {13.1.3}The Destructor}{278}
\contentsline {paragraph}{What a Destructor Does}{278}
\contentsline {paragraph}{When a Destructor Is Called}{278}
\contentsline {paragraph}{The Synthesized Destructor}{279}
\contentsline {subsection}{\numberline {13.1.4}The Rule of Three/Five/Zero}{279}
\contentsline {paragraph}{Rule of three}{279}
\contentsline {paragraph}{Rule of five}{280}
\contentsline {paragraph}{Rule of zero}{280}
\contentsline {paragraph}{Classes That Need Destructors Need Copy and Assignment}{281}
\contentsline {paragraph}{Classes That Need Copy Need Assignment, and Vice Versa}{282}
\contentsline {subsection}{\numberline {13.1.5}Using = default}{283}
\contentsline {subsection}{\numberline {13.1.6}Preventing Copies}{283}
\contentsline {paragraph}{Defining a Function as Deleted}{283}
\contentsline {paragraph}{The Destructor Should Not be a Deleted Member}{283}
\contentsline {paragraph}{The Copy-Control Members May Be Synthesized as Deleted}{283}
\contentsline {paragraph}{private Copy Control}{283}
\contentsline {section}{\numberline {13.2}Copy Control and Resource Management}{283}
\contentsline {subsection}{\numberline {13.2.1}Classes That Act Like Values}{283}
\contentsline {subsection}{\numberline {13.2.2}Defining Classes That Act Like Pointers}{283}
\contentsline {section}{\numberline {13.3}Swap}{283}
\contentsline {section}{\numberline {13.4}A Copy-Control Example}{283}
\contentsline {section}{\numberline {13.5}Classes That Manage Dynamic Memory}{283}
\contentsline {section}{\numberline {13.6}Moving Objects}{283}
\contentsline {subsection}{\numberline {13.6.1}Rvalue References}{283}
\contentsline {paragraph}{Lvalues Persist; Rvalues Are Ephemeral}{283}
\contentsline {paragraph}{Variables Are Lvalues}{283}
\contentsline {paragraph}{The Library move Function}{283}
\contentsline {subsection}{\numberline {13.6.2}Move Constructor and Move Assignment}{283}
\contentsline {paragraph}{Move Operations, Library Containers, and Exceptions}{283}
\contentsline {paragraph}{Move-Assignment Operator}{283}
\contentsline {paragraph}{A Moved-from Object Must Be Destructible}{283}
\contentsline {paragraph}{The Synthesized Move Operations}{283}
\contentsline {paragraph}{Rvalues Are Moved, Lvalues Are Copied ...}{283}
\contentsline {paragraph}{...But Rvalues Are Copied If There Is No Move Constructor}{283}
\contentsline {paragraph}{Copy-and-Swap Assignment Operators and Move}{283}
\contentsline {paragraph}{Move Operations for the Message Class}{283}
\contentsline {paragraph}{Move Iterators}{283}
\contentsline {subsection}{\numberline {13.6.3}Rvalue References and Member Functions}{283}
\contentsline {paragraph}{Rvalue and Lvalue Reference Member Functions}{283}
\contentsline {section}{Chapter Summary}{284}
\contentsline {section}{Defined Terms}{284}
\ttl@stoptoc {default@13}
\contentsline {chapter}{\numberline {14}Overloaded Operations and Conversions}{285}
\ttl@stoptoc {default@13}
\ttl@starttoc {default@14}
\contentsline {section}{\numberline {14.1}Basic Concepts}{286}
\contentsline {paragraph}{Choosing Member or Nonmember Implementation}{286}
\contentsline {section}{\numberline {14.2}Input and Output Operators}{286}
\contentsline {subsection}{\numberline {14.2.1}Overloading the Output Operator <<}{286}
\contentsline {subsection}{\numberline {14.2.2}Overloading the Input Operator >>}{286}
\contentsline {section}{\numberline {14.3}Arithmetic and Relational Operators}{286}
\contentsline {subsection}{\numberline {14.3.1}Equality Operators}{286}
\contentsline {subsection}{\numberline {14.3.2}Relational Operators}{286}
\contentsline {section}{\numberline {14.4}Assignment Operators}{286}
\contentsline {section}{\numberline {14.5}Subscript Operator}{286}
\contentsline {section}{\numberline {14.6}Increment and Decrement Operators}{286}
\contentsline {section}{\numberline {14.7}Member Access Operators}{286}
\contentsline {section}{\numberline {14.8}Function-Call Operator}{286}
\contentsline {subsection}{\numberline {14.8.1}Lambdas Are Function Objects}{286}
\contentsline {subsection}{\numberline {14.8.2}Library-Defined Function Objects}{286}
\contentsline {subsection}{\numberline {14.8.3}Callable Objects and function}{286}
\contentsline {section}{\numberline {14.9}Overloading, Conversions, and Operators}{286}
\contentsline {subsection}{\numberline {14.9.1}Conversion Operators}{286}
\contentsline {subsection}{\numberline {14.9.2}Avoiding Ambiguous Conversions}{286}
\contentsline {subsection}{\numberline {14.9.3}Function Matching and Overloaded Operators}{286}
\contentsline {section}{Chapter Summary}{287}
\contentsline {section}{Defined Terms}{287}
\ttl@stoptoc {default@14}
\contentsline {chapter}{\numberline {15}Object-Oriented Programming}{288}
\ttl@stoptoc {default@14}
\ttl@starttoc {default@15}
\contentsline {section}{\numberline {15.1}OOP: An Overview}{289}
\contentsline {paragraph}{Inheritance}{289}
\contentsline {paragraph}{Dynamic Binding}{289}
\contentsline {section}{\numberline {15.2}Defining Base and Derived Classes}{290}
\contentsline {subsection}{\numberline {15.2.1}Defining a Base Class}{290}
\contentsline {paragraph}{Member Functions and Inheritance}{291}
\contentsline {paragraph}{Access Control and Inheritance}{291}
\contentsline {subsection}{\numberline {15.2.2}Defining a Derived Class}{291}
\contentsline {paragraph}{Virtual Functions in the Derived Class}{292}
\contentsline {paragraph}{Derived-Class Objects and the Derived-to-Base Conversion}{292}
\contentsline {paragraph}{Derived-Class Constructors}{293}
\contentsline {paragraph}{Using Members of the Base Class from the Derived Class}{293}
\contentsline {paragraph}{Inheritance and static Members}{294}
\contentsline {paragraph}{Declarations of Derived Classes}{294}
\contentsline {paragraph}{Classes Used as a Base Class}{294}
\contentsline {paragraph}{Preventing Inheritance}{295}
\contentsline {subsection}{\numberline {15.2.3}Conversions and Inheritance}{295}
\contentsline {paragraph}{Static Type and Dynamic Type}{295}
\contentsline {paragraph}{There Is No Implicit Conversion from Base to Derived ...}{296}
\contentsline {paragraph}{...and No Conversion between Objects}{296}
\contentsline {section}{\numberline {15.3}Virtual Functions}{297}
\contentsline {paragraph}{Calls to Virtual Functions May Be Resolved at Run Time}{297}
\contentsline {paragraph}{Virtual Functions in a Derived Class}{298}
\contentsline {paragraph}{The final and override Specifiers}{298}
\contentsline {paragraph}{Virtual Functions and Default Arguments}{299}
\contentsline {paragraph}{Circumventing the Virtual Mechanism}{299}
\contentsline {section}{\numberline {15.4}Abstract Base Classes}{301}
\contentsline {paragraph}{Pure Virtual Functions}{301}
\contentsline {paragraph}{Classes with Pure Virtuals Are Abstract Base Classes}{301}
\contentsline {paragraph}{A Derived Class Constructor Initializes Its Direct Base Class Only}{302}
\contentsline {section}{\numberline {15.5}Access Control and Inheritance}{302}
\contentsline {paragraph}{protected Members}{302}
\contentsline {paragraph}{public, private, and protected Inheritance}{303}
\contentsline {paragraph}{Accessibility of Derived-to-Base Conversion}{304}
\contentsline {paragraph}{Friendship and Inheritance}{305}
\contentsline {paragraph}{Exempting Individual Members}{306}
\contentsline {paragraph}{Default Inheritance Protection Levels}{306}
\contentsline {section}{\numberline {15.6}Class Scope under Inheritance}{307}
\contentsline {paragraph}{Name Lookup Happens at Compile Time}{307}
\contentsline {paragraph}{Name Collisions and Inheritance}{308}
\contentsline {paragraph}{Using the Scope Operator to Use Hidden Members}{308}
\contentsline {paragraph}{As Usual, Name Lookup Happens before Type Checking}{309}
\contentsline {paragraph}{Virtual Functions and Scope}{309}
\contentsline {paragraph}{Calling a Hidden Virtual through the Base Class}{310}
\contentsline {paragraph}{Overriding Overloaded Functions}{310}
\contentsline {section}{\numberline {15.7}Constructors and Copy Control}{311}
\contentsline {subsection}{\numberline {15.7.1}Virtual Destructors}{311}
\contentsline {paragraph}{Virtual Destructors Turn Off Synthesized Move}{312}
\contentsline {subsection}{\numberline {15.7.2}Synthesized Copy Control and Inheritance}{312}
\contentsline {paragraph}{Base Classes and Deleted Copy Control in the Derived}{312}
\contentsline {paragraph}{Move Operations and Inheritance}{313}
\contentsline {subsection}{\numberline {15.7.3}Derived-Class Copy-Control Members}{313}
\contentsline {paragraph}{Defining a Derived Copy or Move Constructor}{314}
\contentsline {paragraph}{Derived-Class Assignment Operator}{314}
\contentsline {paragraph}{Derived-Class Destructor}{315}
\contentsline {paragraph}{Calls to Virtuals in Constructors and Destructors}{315}
\contentsline {subsection}{\numberline {15.7.4}Inherited Constructors}{315}
\contentsline {paragraph}{Characteristics of an Inherited Constructor}{316}
\contentsline {section}{\numberline {15.8}Containers and Inheritance}{316}
\contentsline {paragraph}{Put (Smart) Pointers, Not Objects, in Containers}{317}
\contentsline {subsection}{\numberline {15.8.1}Writing a Basket Class}{317}
\contentsline {paragraph}{Defining the Members of Basket}{318}
\contentsline {paragraph}{Hiding the Pointers}{318}
\contentsline {paragraph}{Simulating Virtual Copy}{319}
\contentsline {section}{\numberline {15.9}Text Queries Revisited}{320}
\contentsline {subsection}{\numberline {15.9.1}An Object-Oriented Solution}{321}
\contentsline {subsection}{\numberline {15.9.2}The Query\texttt {\_}base and Query Classes}{321}
\contentsline {subsection}{\numberline {15.9.3}The Derived Classes}{321}
\contentsline {subsection}{\numberline {15.9.4}The eval Functions}{321}
\contentsline {section}{Chapter Summary}{322}
\contentsline {section}{Defined Terms}{322}
\ttl@stoptoc {default@15}
\contentsline {chapter}{\numberline {16}Templates and Generic Programming}{323}
\ttl@stoptoc {default@15}
\ttl@starttoc {default@16}
\contentsline {section}{\numberline {16.1}Defining a Template}{324}
\contentsline {subsection}{\numberline {16.1.1}Function Templates}{324}
\contentsline {paragraph}{Instantiating a Function Template}{324}
\contentsline {paragraph}{Template Type Parameters}{324}
\contentsline {paragraph}{Nontype Template Parameters}{324}
\contentsline {paragraph}{inline and constexpr Function Templates}{324}
\contentsline {paragraph}{Writing Type-Independent Code}{324}
\contentsline {paragraph}{Template Compilation}{324}
\contentsline {paragraph}{Compilation Errors Are Mostly Reported during Instantiation}{324}
\contentsline {subsection}{\numberline {16.1.2}Class Templates}{324}
\contentsline {subsection}{\numberline {16.1.3}Template Parameters}{324}
\contentsline {subsection}{\numberline {16.1.4}Member Templates}{324}
\contentsline {subsection}{\numberline {16.1.5}Controlling Instantiations}{324}
\contentsline {subsection}{\numberline {16.1.6}Efficiency and Flexibility}{324}
\contentsline {section}{\numberline {16.2}Template Argument Deduction}{324}
\contentsline {subsection}{\numberline {16.2.1}Conversions and Template Type Parameters}{324}
\contentsline {subsection}{\numberline {16.2.2}Function-Template Explicit Arguments}{324}
\contentsline {subsection}{\numberline {16.2.3}Trailing Return Types and Type Transformation}{324}
\contentsline {subsection}{\numberline {16.2.4}Function Pointers and Argument Deduction}{324}
\contentsline {subsection}{\numberline {16.2.5}Template Argument Deduction and References}{324}
\contentsline {subsection}{\numberline {16.2.6}Understanding std::move}{324}
\contentsline {subsection}{\numberline {16.2.7}Forwarding}{324}
\contentsline {section}{\numberline {16.3}Overloading and Templates}{324}
\contentsline {section}{\numberline {16.4}Variadic Templates}{324}
\contentsline {subsection}{\numberline {16.4.1}Writing a Variadic Function Template}{324}
\contentsline {subsection}{\numberline {16.4.2}Pack Expansion}{324}
\contentsline {subsection}{\numberline {16.4.3}Forwarding Parameter Packs}{324}
\contentsline {section}{\numberline {16.5}Template Specializations}{324}
\contentsline {section}{Chapter Summary}{325}
\contentsline {section}{Defined Terms}{325}
\ttl@stoptoc {default@16}
\contentsline {part}{IV\hspace {1em}Advanced Topics}{326}
\ttl@stoptoc {parts@3}
\ttl@starttoc {parts@4}
\contentsline {chapter}{\numberline {17}Specialized Library Facilities}{327}
\ttl@stoptoc {default@16}
\ttl@starttoc {default@17}
\contentsline {section}{\numberline {17.1}The tuple Type}{328}
\contentsline {subsection}{\numberline {17.1.1}Defining and Initializing tuples}{328}
\contentsline {subsection}{\numberline {17.1.2}Using a tuple to Return Multiple Values}{328}
\contentsline {section}{\numberline {17.2}The bitset Type}{328}
\contentsline {subsection}{\numberline {17.2.1}Defining and Initializing bitsets}{328}
\contentsline {subsection}{\numberline {17.2.2}Operations on bitsets}{328}
\contentsline {section}{\numberline {17.3}Regular Expressions}{328}
\contentsline {subsection}{\numberline {17.3.1}Using the Regular Expression Library}{328}
\contentsline {subsection}{\numberline {17.3.2}The Match and Regex Iterator Types}{328}
\contentsline {subsection}{\numberline {17.3.3}Using Subexpressions}{328}
\contentsline {subsection}{\numberline {17.3.4}Using regex\texttt {\_}replace}{328}
\contentsline {section}{\numberline {17.4}Random Numbers}{328}
\contentsline {subsection}{\numberline {17.4.1}Random-Number Engines and Distribution}{328}
\contentsline {subsection}{\numberline {17.4.2}Other Kinds of Distributions}{328}
\contentsline {section}{\numberline {17.5}The IO Library Revisited}{328}
\contentsline {subsection}{\numberline {17.5.1}Formatted Input and Output}{328}
\contentsline {subsection}{\numberline {17.5.2}Unformatted Input/Output Operations}{328}
\contentsline {subsection}{\numberline {17.5.3}Random Access to a Stream}{328}
\contentsline {paragraph}{Seek and Tell Functions}{328}
\contentsline {paragraph}{There Is Only One Marker}{328}
\contentsline {paragraph}{Repositioning the Marker}{328}
\contentsline {paragraph}{Accessing the Marker}{328}
\contentsline {paragraph}{Reading and Writing to the Same File}{328}
\contentsline {section}{Chapter Summary}{329}
\contentsline {section}{Defined Terms}{329}
\ttl@stoptoc {default@17}
\contentsline {chapter}{\numberline {18}Tools for Large Programs}{330}
\ttl@stoptoc {default@17}
\ttl@starttoc {default@18}
\contentsline {section}{\numberline {18.1}Exception Handling}{330}
\contentsline {subsection}{\numberline {18.1.1}Throwing an Exception}{330}
\contentsline {subsection}{\numberline {18.1.2}Catching an Exception}{330}
\contentsline {subsection}{\numberline {18.1.3}Function try Blocks and Constructors}{330}
\contentsline {subsection}{\numberline {18.1.4}The noexcept Exception Specification}{330}
\contentsline {subsection}{\numberline {18.1.5}Exception Class Hierarchies}{330}
\contentsline {section}{\numberline {18.2}Namespaces}{330}
\contentsline {subsection}{\numberline {18.2.1}Namespace Definitions}{330}
\contentsline {subsection}{\numberline {18.2.2}Using Namespace Members}{330}
\contentsline {subsection}{\numberline {18.2.3}Classes, Namespaces, and Scope}{330}
\contentsline {subsection}{\numberline {18.2.4}Overloading and Namespaces}{330}
\contentsline {section}{\numberline {18.3}Multiple and Virtual Inheritance}{330}
\contentsline {subsection}{\numberline {18.3.1}Multiple Inheritance}{330}
\contentsline {subsection}{\numberline {18.3.2}Multiple Inheritance}{330}
\contentsline {subsection}{\numberline {18.3.3}Class Scope under Multiple Inheritance}{330}
\contentsline {subsection}{\numberline {18.3.4}Virtual Inheritance}{330}
\contentsline {subsection}{\numberline {18.3.5}Constructors and Virtual Inheritance}{330}
\contentsline {section}{Chapter Summary}{331}
\contentsline {section}{Defined Terms}{331}
\ttl@stoptoc {default@18}
\contentsline {chapter}{\numberline {19}Specialized Tools and Techniques}{332}
\ttl@stoptoc {default@18}
\ttl@starttoc {default@19}
\contentsline {section}{\numberline {19.1}Controlling Memory Allocation}{333}
\contentsline {subsection}{\numberline {19.1.1}Overloading new and delete}{333}
\contentsline {subsection}{\numberline {19.1.2}Placement new Expressions}{333}
\contentsline {section}{\numberline {19.2}Run-Time Type Identification}{333}
\contentsline {subsection}{\numberline {19.2.1}The dynamic\texttt {\_}cast Operator}{333}
\contentsline {subsection}{\numberline {19.2.2}The typeid Operator}{333}
\contentsline {subsection}{\numberline {19.2.3}Using RTTI}{333}
\contentsline {subsection}{\numberline {19.2.4}The type\texttt {\_}info Class}{333}
\contentsline {section}{\numberline {19.3}Enumerations}{333}
\contentsline {section}{\numberline {19.4}Pointer to Class Member}{333}
\contentsline {subsection}{\numberline {19.4.1}Pointers to Data Members}{333}
\contentsline {subsection}{\numberline {19.4.2}Pointers to Member Functions}{333}
\contentsline {subsection}{\numberline {19.4.3}Using Member Functions as Callable Objects}{333}
\contentsline {section}{\numberline {19.5}Nested Classes}{333}
\contentsline {section}{\numberline {19.6}union: A Space-Saving Class}{333}
\contentsline {section}{\numberline {19.7}Local Classes}{333}
\contentsline {section}{\numberline {19.8}Inherently Nonportable Features}{333}
\contentsline {subsection}{\numberline {19.8.1}Bit-fields}{333}
\contentsline {subsection}{\numberline {19.8.2}volatile Qualifier}{333}
\contentsline {subsection}{\numberline {19.8.3}Linkage Directives: extern "C"}{333}
\contentsline {section}{Chapter Summary}{334}
\contentsline {section}{Defined Terms}{334}
\ttl@stoptoc {default@19}
\renewcommand *{\chaptername }{\appendixname }
\contentsline {chapter}{\numberline {A}The Library}{335}
\ttl@stoptoc {default@19}
\ttl@starttoc {default@20}
\contentsline {section}{\numberline {A.1}Library Names and Headers}{336}
\contentsline {section}{\numberline {A.2}Brief Tour of the Algorithms}{339}
\contentsline {subsection}{\numberline {A.2.1}Algorithms to Find an Object}{339}
\contentsline {subsection}{\numberline {A.2.2}Other Read-Only Algorithms}{339}
\contentsline {subsection}{\numberline {A.2.3}Binary Search Algorithms}{339}
\contentsline {subsection}{\numberline {A.2.4}Algorithms That Write Container Elements}{339}
\contentsline {subsection}{\numberline {A.2.5}Partitioning and Sorting Algorithms}{339}
\contentsline {subsection}{\numberline {A.2.6}General Reordering Operations}{339}
\contentsline {subsection}{\numberline {A.2.7}Permutation Algorithms}{339}
\contentsline {subsection}{\numberline {A.2.8}Set Algorithms for Sorted Sequences}{339}
\contentsline {subsection}{\numberline {A.2.9}Minimum and Maximum Values}{339}
\contentsline {subsection}{\numberline {A.2.10}Numeric Algorithms}{339}
\contentsline {section}{\numberline {A.3}Random Numbers}{339}
\contentsline {subsection}{\numberline {A.3.1}Random Number Distributions}{339}
\contentsline {subsection}{\numberline {A.3.2}Random Number Engines}{339}
\ttl@stoptoc {default@20}
\contentsline {chapter}{Index}{340}
\contentsfinish 
