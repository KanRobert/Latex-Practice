\contentsline {chapter}{\numberline {1}Getting Started}{1}
\ttl@starttoc {default@1}
\contentsline {section}{\numberline {1.1}Writing a Simple C++ Program}{2}
\contentsline {subsection}{\numberline {1.1.1}Compiling and Executing Our Program}{3}
\contentsline {paragraph}{Program Source File Naming Convention}{3}
\contentsline {paragraph}{Running the Compiler from the Command Line}{3}
\contentsline {section}{\numberline {1.2}A First Look at Input/Output}{4}
\contentsline {paragraph}{Standard Input and Output Objects}{4}
\contentsline {paragraph}{A Program That Uses the IO Library}{4}
\contentsline {paragraph}{Writing to a Stream}{5}
\contentsline {paragraph}{Using Names from the Standard Library}{6}
\contentsline {paragraph}{Reading from a Stream}{6}
\contentsline {paragraph}{Completing the Program}{6}
\contentsline {section}{\numberline {1.3}A Word about Comments}{7}
\contentsline {paragraph}{Kinds of Comments in C++}{7}
\contentsline {paragraph}{Comment Pairs Do Not Nest}{7}
\contentsline {section}{\numberline {1.4}Flow of Control}{8}
\contentsline {subsection}{\numberline {1.4.1}The while Statement}{8}
\contentsline {subsection}{\numberline {1.4.2}The for Statement}{9}
\contentsline {subsection}{\numberline {1.4.3}Reading an Unknown Number of Inputs}{10}
\contentsline {subsection}{\numberline {1.4.4}The if Statement}{12}
\contentsline {section}{\numberline {1.5}Introducing Classes}{14}
\contentsline {subsection}{\numberline {1.5.1}The Sales\_item Class}{14}
\contentsline {paragraph}{Reading and Writing Sales\_items}{15}
\contentsline {paragraph}{Adding Sales\_items}{15}
\contentsline {subsection}{\numberline {1.5.2}A First Look at Member Functions}{16}
\contentsline {paragraph}{What Is a Member Function?}{17}
\contentsline {section}{\numberline {1.6}The Bookstore Program}{17}
\contentsline {section}{Chapter Summary}{19}
\contentsline {section}{Defined Terms}{19}
\ttl@stoptoc {default@1}
\contentsline {part}{I\hspace {1em}The Basics}{22}
\ttl@starttoc {parts@1}
\contentsline {chapter}{\numberline {2}Variables and Basic Types}{24}
\ttl@stoptoc {default@1}
\ttl@starttoc {default@2}
\contentsline {section}{\numberline {2.1}Primitive Built-in Types}{25}
\contentsline {subsection}{\numberline {2.1.1}Arithmetic Types}{25}
\contentsline {paragraph}{Signed and Unsigned Types}{26}
\contentsline {subsection}{\numberline {2.1.2}Type Conversions}{27}
\contentsline {paragraph}{Expressions Involving Unsigned Types}{28}
\contentsline {subsection}{\numberline {2.1.3}Literals}{29}
\contentsline {paragraph}{Integer and Floating-Point Literals}{29}
\contentsline {paragraph}{Character and Character String Literals}{30}
\contentsline {paragraph}{Escape Sequences}{30}
\contentsline {paragraph}{Specifying the Type of a Literal}{31}
\contentsline {paragraph}{Boolean and Pointer Literals}{31}
\contentsline {section}{\numberline {2.2}Variables}{32}
\contentsline {subsection}{\numberline {2.2.1}Variable Definitions}{32}
\contentsline {paragraph}{Initializers}{33}
\contentsline {paragraph}{List Initialization}{33}
\contentsline {paragraph}{Default Initialization}{34}
\contentsline {subsection}{\numberline {2.2.2}Variable Declarations and Definitions}{35}
\contentsline {subsection}{\numberline {2.2.3}Identifiers}{36}
\contentsline {paragraph}{Conventions for Variable Names}{36}
\contentsline {subsection}{\numberline {2.2.4}Scope of a Name}{37}
\contentsline {paragraph}{Nested Scopes}{37}
\contentsline {section}{\numberline {2.3}Compound Types}{38}
\contentsline {subsection}{\numberline {2.3.1}References}{39}
\contentsline {paragraph}{A Reference Is an Alias}{39}
\contentsline {paragraph}{Reference Definitions}{39}
\contentsline {subsection}{\numberline {2.3.2}Pointers}{40}
\contentsline {paragraph}{Taking the Address of an Object}{40}
\contentsline {paragraph}{Pointer Value}{41}
\contentsline {paragraph}{Using a Pointer to Access an Object}{41}
\contentsline {paragraph}{Null Pointers}{41}
\contentsline {paragraph}{Assignment and Pointers}{42}
\contentsline {paragraph}{Other Pointer Operations}{43}
\contentsline {paragraph}{void* Pointers}{43}
\contentsline {subsection}{\numberline {2.3.3}Understanding Compound Type Declarations}{44}
\contentsline {paragraph}{Defining Multiple Variables}{44}
\contentsline {paragraph}{Pointers to Pointers}{45}
\contentsline {paragraph}{References to Pointers}{45}
\contentsline {section}{\numberline {2.4}const Qualifier}{46}
\contentsline {paragraph}{Initialization and const}{46}
\contentsline {paragraph}{By Default, const Objects Are Local to a File}{46}
\contentsline {subsection}{\numberline {2.4.1}References to const}{47}
\contentsline {paragraph}{Initialization and References to const}{47}
\contentsline {paragraph}{A Reference to const May Refer to an Object That Is Not const}{48}
\contentsline {subsection}{\numberline {2.4.2}Pointers and const}{48}
\contentsline {paragraph}{const Pointers}{49}
\contentsline {subsection}{\numberline {2.4.3}Top-Level const}{50}
\contentsline {subsection}{\numberline {2.4.4}constexpr and Constant Expressions}{51}
\contentsline {paragraph}{constexpr Variables}{51}
\contentsline {paragraph}{Literal Types}{52}
\contentsline {paragraph}{Pointers and constexpr}{52}
\contentsline {section}{\numberline {2.5}Dealing with Types}{52}
\contentsline {subsection}{\numberline {2.5.1}Type Aliases}{53}
\contentsline {paragraph}{Pointers, const, and Type Aliases}{53}
\contentsline {subsection}{\numberline {2.5.2}The auto Type Specifier}{53}
\contentsline {paragraph}{Compound Types, const, and auto}{54}
\contentsline {subsection}{\numberline {2.5.3}The decltype Type Specifier}{54}
\contentsline {paragraph}{decltype and References}{55}
\contentsline {section}{\numberline {2.6}Defining Our Own Data Structures}{56}
\contentsline {subsection}{\numberline {2.6.1}Defining the Sales\_data Type}{56}
\contentsline {paragraph}{Class Data Members}{57}
\contentsline {subsection}{\numberline {2.6.2}Using the Sales\_data Type}{57}
\contentsline {paragraph}{Adding Two Sales\_data Objects}{57}
\contentsline {paragraph}{Reading Data into a Sales\_data Object}{58}
\contentsline {paragraph}{Printing the Sum of Two Sales\_data Objects}{58}
\contentsline {subsection}{\numberline {2.6.3}Writing Our Own Header Files}{59}
\contentsline {paragraph}{A Brief Introduction to the Preprocessor}{59}
\contentsline {section}{Chapter Summary}{61}
\contentsline {section}{Defined Terms}{61}
\ttl@stoptoc {default@2}
\contentsline {chapter}{\numberline {3}Strings, Vectors, and Arrays}{64}
\ttl@stoptoc {default@2}
\ttl@starttoc {default@3}
\contentsline {section}{\numberline {3.1}Namespace using Declarations}{65}
\contentsline {paragraph}{A Separate using Declaration Is Required for Each Name}{65}
\contentsline {paragraph}{Headers Should Not Include using Declarations}{66}
\contentsline {paragraph}{A Note to the Reader}{66}
\contentsline {section}{\numberline {3.2}Library \texttt {string} Type}{66}
\contentsline {subsection}{\numberline {3.2.1}Defining and Initializing strings}{66}
\contentsline {paragraph}{Direct and Copy Forms of Initialization}{67}
\contentsline {subsection}{\numberline {3.2.2}Operations on strings}{67}
\contentsline {paragraph}{Reading and Writing strings}{67}
\contentsline {paragraph}{Using getline to Read an Entire Line}{68}
\contentsline {paragraph}{The string empty and size Operations}{68}
\contentsline {paragraph}{The \texttt {string::size\_type} Type}{68}
\contentsline {paragraph}{Comparing strings}{69}
\contentsline {paragraph}{Assignment for strings}{69}
\contentsline {paragraph}{Adding Two strings}{69}
\contentsline {paragraph}{Adding Literals and strings}{70}
\contentsline {subsection}{\numberline {3.2.3}Dealing with the Characters in a string}{70}
\contentsline {paragraph}{Processing Every Character? Use Range-Based for}{71}
\contentsline {paragraph}{Using a Range for to Change the Characters in a string}{72}
\contentsline {paragraph}{Processing Only Some Characters?}{72}
\contentsline {paragraph}{Using a Subscript for Iteration}{73}
\contentsline {paragraph}{Using a Subscript for Random Access}{73}
\contentsline {section}{\numberline {3.3}Library \texttt {vector} Type}{74}
\contentsline {subsection}{\numberline {3.3.1}Defining and Initializing vectors}{75}
\contentsline {paragraph}{List Initializing a vector}{75}
\contentsline {paragraph}{Creating a Specified Number of Elements}{76}
\contentsline {paragraph}{Value Initialization}{76}
\contentsline {paragraph}{List Initializer or Element Count?}{76}
\contentsline {subsection}{\numberline {3.3.2}Adding Elements to a vector}{77}
\contentsline {paragraph}{Programming Implications of Adding Elements to a vector}{78}
\contentsline {subsection}{\numberline {3.3.3}Other vector Operations}{78}
\contentsline {paragraph}{Computing a vector Index}{79}
\contentsline {paragraph}{Subscripting Does Not Add Elements}{80}
\contentsline {section}{\numberline {3.4}Introducing Iterators}{81}
\contentsline {subsection}{\numberline {3.4.1}Using Iterators}{81}
\contentsline {paragraph}{Iterator Operations}{81}
\contentsline {paragraph}{Moving Iterators from One Element to Another}{82}
\contentsline {paragraph}{Iterator Types}{83}
\contentsline {paragraph}{The begin and end Operations}{83}
\contentsline {paragraph}{Combining Dereference and Member Access}{83}
\contentsline {paragraph}{Some vector Operations Invalidate Iterators}{84}
\contentsline {subsection}{\numberline {3.4.2}Iterator Arithmetic}{84}
\contentsline {paragraph}{Arithmetic Operations on Iterators}{85}
\contentsline {paragraph}{Using Iterator Arithmetic}{85}
\contentsline {section}{\numberline {3.5}Arrays}{86}
\contentsline {subsection}{\numberline {3.5.1}Defining and Initializing Built-in Arrays}{86}
\contentsline {paragraph}{Explicitly Initializing Array Elements}{87}
\contentsline {paragraph}{Character Arrays Are Special}{87}
\contentsline {paragraph}{No Copy or Assignment}{87}
\contentsline {paragraph}{Understanding Complicated Array Declarations}{87}
\contentsline {subsection}{\numberline {3.5.2}Accessing the Elements of an Array}{88}
\contentsline {paragraph}{Checking Subscript Values}{89}
\contentsline {subsection}{\numberline {3.5.3}Pointers and Arrays}{89}
\contentsline {paragraph}{Pointers Are Iterators}{90}
\contentsline {paragraph}{The Library begin and end Functions}{90}
\contentsline {paragraph}{Pointer Arithmetic}{91}
\contentsline {paragraph}{Interaction between Dereference and Pointer Arithmetic}{92}
\contentsline {paragraph}{Subscripts and Pointers}{92}
\contentsline {subsection}{\numberline {3.5.4}C-Style Character Strings}{93}
\contentsline {paragraph}{C Library String Functions}{93}
\contentsline {paragraph}{Comparing Strings}{93}
\contentsline {paragraph}{Caller Is Responsible for Size of a Destination String}{94}
\contentsline {subsection}{\numberline {3.5.5}Interfacing to Older Code}{94}
\contentsline {paragraph}{Mixing Library strings and C-Style Strings}{94}
\contentsline {paragraph}{Using an Array to Initialize a vector}{95}
\contentsline {section}{\numberline {3.6}Multidimensional Arrays}{95}
\contentsline {paragraph}{Initializing the Elements of a Multidimensional Array}{96}
\contentsline {paragraph}{Subscripting a Multidimensional Array}{96}
\contentsline {paragraph}{Using a Range for with Multidimensional Arrays}{97}
\contentsline {paragraph}{Pointers and Multidimensional Arrays}{97}
\contentsline {paragraph}{Type Aliases Simplify Pointers to Multidimensional Arrays}{98}
\contentsline {section}{Chapter Summary}{100}
\contentsline {section}{Defined Terms}{100}
\ttl@stoptoc {default@3}
\contentsline {chapter}{\numberline {4}Expressions}{102}
\ttl@stoptoc {default@3}
\ttl@starttoc {default@4}
\contentsline {section}{\numberline {4.1}Fundamentals}{103}
\contentsline {subsection}{\numberline {4.1.1}Basic Concepts}{103}
\contentsline {paragraph}{Grouping Operators and Operands}{103}
\contentsline {paragraph}{Operand Conversions}{103}
\contentsline {paragraph}{Overloaded Operators}{103}
\contentsline {paragraph}{Lvalues and Rvalues}{103}
\contentsline {subsection}{\numberline {4.1.2}Precedence and Associativity}{104}
\contentsline {paragraph}{Parentheses Override Precedence and Associativity}{104}
\contentsline {paragraph}{When Precedence and Associativity Matter}{105}
\contentsline {subsection}{\numberline {4.1.3}Order of Evaluation}{105}
\contentsline {paragraph}{Order of Evaluation, Precedence, and Associativity}{105}
\contentsline {section}{\numberline {4.2}Arithmetic Operators}{106}
\contentsline {section}{\numberline {4.3}Logical and Relational Operators}{108}
\contentsline {paragraph}{Logical AND and OR Operators}{108}
\contentsline {paragraph}{Logical NOT Operator}{109}
\contentsline {paragraph}{The Relational Operators}{109}
\contentsline {paragraph}{Equality Tests and the bool Literals}{109}
\contentsline {section}{\numberline {4.4}Assignment Operators}{110}
\contentsline {paragraph}{Assignment Is Right Associative}{111}
\contentsline {paragraph}{Assignment Has Low Precedence}{111}
\contentsline {paragraph}{Beware of Confusing Equality and Assignment Operators}{111}
\contentsline {paragraph}{Compound Assignment Operators}{112}
\contentsline {section}{\numberline {4.5}Increment and Decrement Operators}{112}
\contentsline {paragraph}{Combining Dereference and Increment in a Single Expression}{113}
\contentsline {paragraph}{Remember That Operands Can Be Evaluated in Any Order}{113}
\contentsline {section}{\numberline {4.6}The Member Access Operators}{114}
\contentsline {section}{\numberline {4.7}The Conditional Operator}{115}
\contentsline {paragraph}{Nesting Conditional Operations}{115}
\contentsline {paragraph}{Using a Conditional Operator in an Output Expression}{115}
\contentsline {section}{\numberline {4.8}The Bitwise Operators}{116}
\contentsline {paragraph}{Bitwise Shift Operators}{117}
\contentsline {paragraph}{Bitwise NOT Operator}{117}
\contentsline {paragraph}{Bitwise AND, OR, and XOR Operators}{117}
\contentsline {paragraph}{Using Bitwise Operators}{118}
\contentsline {paragraph}{Shift Operators (aka IO Operators) Are Left Associative}{118}
\contentsline {section}{\numberline {4.9}The sizeof Operator}{119}
\contentsline {section}{\numberline {4.10}Comma Operator}{120}
\contentsline {section}{\numberline {4.11}Type Conversions}{121}
\contentsline {paragraph}{When Implicit Conversions Occur}{121}
\contentsline {subsection}{\numberline {4.11.1}The Arithmetic Conversions}{121}
\contentsline {paragraph}{Integral Promotions}{122}
\contentsline {paragraph}{Operands of Unsigned Type}{122}
\contentsline {paragraph}{Understanding the Arithmetic Conversions}{122}
\contentsline {subsection}{\numberline {4.11.2}Other Implicit Conversions}{123}
\contentsline {subsection}{\numberline {4.11.3}Explicit Conversions}{124}
\contentsline {paragraph}{Named Casts}{124}
\contentsline {paragraph}{\texttt {static\_cast}}{124}
\contentsline {paragraph}{\texttt {const\_cast}}{125}
\contentsline {paragraph}{\texttt {reinterpret\_cast}}{125}
\contentsline {paragraph}{Old-Style Casts}{125}
\contentsline {section}{\numberline {4.12}Operator Precedence Table}{126}
\contentsline {section}{Chapter Summary}{128}
\contentsline {section}{Defined Terms}{128}
\ttl@stoptoc {default@4}
\contentsline {chapter}{\numberline {5}Statements}{130}
\ttl@stoptoc {default@4}
\ttl@starttoc {default@5}
\contentsline {section}{\numberline {5.1}Simple Statements}{131}
\contentsline {paragraph}{Null Statements}{131}
\contentsline {paragraph}{Beware of Missing or Extraneous Semicolons}{131}
\contentsline {paragraph}{Compound Statements (Blocks)}{132}
\contentsline {section}{\numberline {5.2}Statement Scope}{132}
\contentsline {section}{\numberline {5.3}Conditional Statements}{133}
\contentsline {subsection}{\numberline {5.3.1}The if Statement}{133}
\contentsline {paragraph}{Using an if else Statement}{133}
\contentsline {paragraph}{Nested if Statements}{134}
\contentsline {paragraph}{Watch Your Braces}{134}
\contentsline {paragraph}{Dangling else}{134}
\contentsline {paragraph}{Controlling the Execution Path with Braces}{135}
\contentsline {subsection}{\numberline {5.3.2}The switch Statement}{136}
\contentsline {paragraph}{Control Flow within a switch}{137}
\contentsline {paragraph}{Forgetting a break Is a Common Source of Bugs}{138}
\contentsline {paragraph}{The default Label}{138}
\contentsline {paragraph}{Variable Definitions inside the Body of a switch}{139}
\contentsline {section}{\numberline {5.4}Iterative Statements}{141}
\contentsline {subsection}{\numberline {5.4.1}The while Statement}{141}
\contentsline {paragraph}{Using a while Loop}{141}
\contentsline {subsection}{\numberline {5.4.2}Traditional for Statement}{141}
\contentsline {paragraph}{Execution Flow in a Traditional for Loop}{142}
\contentsline {paragraph}{Multiple Definitions in the for Header}{142}
\contentsline {paragraph}{Omitting Parts of the for Header}{142}
\contentsline {subsection}{\numberline {5.4.3}Range for Statement}{143}
\contentsline {subsection}{\numberline {5.4.4}The do while Statement}{144}
\contentsline {section}{\numberline {5.5}Jump Statements}{145}
\contentsline {subsection}{\numberline {5.5.1}The break Statement}{145}
\contentsline {subsection}{\numberline {5.5.2}The continue Statement}{146}
\contentsline {subsection}{\numberline {5.5.3}The goto Statement}{146}
\contentsline {section}{\numberline {5.6}try Blocks and Exception Handling}{147}
\contentsline {subsection}{\numberline {5.6.1}A throw Expression}{147}
\contentsline {subsection}{\numberline {5.6.2}The try Block}{148}
\contentsline {paragraph}{Writing a Handler}{148}
\contentsline {paragraph}{Functions Are Exited during the Search for a Handler}{149}
\contentsline {subsection}{\numberline {5.6.3}Standard Exceptions}{150}
\contentsline {section}{Chapter Summary}{152}
\contentsline {section}{Defined Terms}{152}
\ttl@stoptoc {default@5}
\contentsline {chapter}{\numberline {6}Functions}{154}
\ttl@stoptoc {default@5}
\ttl@starttoc {default@6}
\contentsline {section}{\numberline {6.1}Function Basics}{155}
\contentsline {paragraph}{Writing a Function}{155}
\contentsline {paragraph}{Calling a Function}{155}
\contentsline {paragraph}{Parameters and Arguments}{156}
\contentsline {paragraph}{Function Parameter List}{156}
\contentsline {paragraph}{Function Return Type}{156}
\contentsline {subsection}{\numberline {6.1.1}Local Objects}{157}
\contentsline {paragraph}{Automatic Objects}{157}
\contentsline {paragraph}{Local static Objects}{157}
\contentsline {subsection}{\numberline {6.1.2}Function Declarations}{158}
\contentsline {paragraph}{Function Declarations Go in Header Files}{158}
\contentsline {subsection}{\numberline {6.1.3}Separate Compilation}{159}
\contentsline {paragraph}{Compiling and Linking Multiple Source Files}{159}
\contentsline {section}{\numberline {6.2}Argument Passing}{159}
\contentsline {subsection}{\numberline {6.2.1}Passing Arguments by Value}{160}
\contentsline {paragraph}{Pointer Parameters}{160}
\contentsline {subsection}{\numberline {6.2.2}Passing Arguments by Reference}{160}
\contentsline {paragraph}{Using References to Avoid Copies}{161}
\contentsline {paragraph}{Using Reference Parameters to Return Additional Information}{161}
\contentsline {subsection}{\numberline {6.2.3}const Parameters and Arguments}{162}
\contentsline {paragraph}{Pointer or Reference Parameters and const}{162}
\contentsline {paragraph}{Use Reference to const When Possible}{163}
\contentsline {subsection}{\numberline {6.2.4}Array Parameters}{164}
\contentsline {paragraph}{Using a Marker to Specify the Extent of an Array}{165}
\contentsline {paragraph}{Using the Standard Library Conventions}{165}
\contentsline {paragraph}{Explicitly Passing a Size Parameter}{165}
\contentsline {paragraph}{Array Parameters and const}{166}
\contentsline {paragraph}{Array Reference Parameters}{166}
\contentsline {paragraph}{Passing a Multidimensional Array}{166}
\contentsline {subsection}{\numberline {6.2.5}\texttt {main}: Handling Command-Line Options}{167}
\contentsline {subsection}{\numberline {6.2.6}Functions with Varying Parameters}{168}
\contentsline {paragraph}{initializer\texttt {\_}list Parameters}{168}
\contentsline {paragraph}{Ellipsis Parameters}{169}
\contentsline {section}{\numberline {6.3}Return Types and the return Statement}{170}
\contentsline {subsection}{\numberline {6.3.1}Functions with No Return Value}{170}
\contentsline {subsection}{\numberline {6.3.2}Functions That Return a Value}{170}
\contentsline {paragraph}{How Values Are Returned}{171}
\contentsline {paragraph}{Never Return a Reference or Pointer to a Local Object}{171}
\contentsline {paragraph}{Functions That Return Class Types and the Call Operator}{172}
\contentsline {paragraph}{Reference Returns Are Lvalues}{172}
\contentsline {paragraph}{List Initializing the Return Value}{172}
\contentsline {paragraph}{Return from main}{173}
\contentsline {paragraph}{Recursion}{173}
\contentsline {subsection}{\numberline {6.3.3}Returning a Pointer to an Array}{174}
\contentsline {paragraph}{Declaring a Function That Returns a Pointer to an Array}{174}
\contentsline {paragraph}{Using a Trailing Return Type}{175}
\contentsline {paragraph}{Using decltype}{175}
\contentsline {section}{\numberline {6.4}Overloaded Functions}{175}
\contentsline {paragraph}{Defining Overloaded Functions}{176}
\contentsline {paragraph}{Determining Whether Two Parameter Types Differ}{176}
\contentsline {paragraph}{Overloading and const Parameters}{176}
\contentsline {paragraph}{\texttt {const\_cast} and Overloading}{177}
\contentsline {paragraph}{Calling an Overloaded Function}{178}
\contentsline {subsection}{\numberline {6.4.1}Overloading and Scope}{178}
\contentsline {section}{\numberline {6.5}Features for Specialized Uses}{179}
\contentsline {subsection}{\numberline {6.5.1}Default Arguments}{179}
\contentsline {paragraph}{Calling Functions with Default Arguments}{179}
\contentsline {paragraph}{Default Argument Declarations}{180}
\contentsline {paragraph}{Default Argument Initializers}{180}
\contentsline {subsection}{\numberline {6.5.2}Inline and constexpr Functions}{181}
\contentsline {paragraph}{inline Functions Avoid Function Call Overhead}{181}
\contentsline {paragraph}{constexpr Functions}{182}
\contentsline {paragraph}{Put inline and constexpr Functions in Header Files}{182}
\contentsline {subsection}{\numberline {6.5.3}Aids for Debugging}{183}
\contentsline {paragraph}{The assert Preprocessor Macro}{183}
\contentsline {paragraph}{The NDEBUG Preprocessor Variable}{183}
\contentsline {section}{\numberline {6.6}Function Matching}{184}
\contentsline {paragraph}{Determining the Candidate and Viable Functions}{185}
\contentsline {paragraph}{Finding the Best Match, If Any}{185}
\contentsline {paragraph}{Function Matching with Multiple Parameters}{185}
\contentsline {subsection}{\numberline {6.6.1}Argument Type Conversions}{186}
\contentsline {paragraph}{Matches Requiring Promotion or Arithmetic Conversion}{186}
\contentsline {paragraph}{Function Matching and const Arguments}{187}
\contentsline {section}{\numberline {6.7}Pointers to Functions}{188}
\contentsline {paragraph}{Using Function Pointers}{188}
\contentsline {paragraph}{Pointers to Overloaded Functions}{189}
\contentsline {paragraph}{Function Pointer Parameters}{189}
\contentsline {paragraph}{Returning a Pointer to Function}{190}
\contentsline {paragraph}{Using auto or decltype for Function Pointer Types}{190}
\contentsline {section}{Chapter Summary}{191}
\contentsline {section}{Defined Terms}{191}
\ttl@stoptoc {default@6}
\contentsline {chapter}{\numberline {7}Classes}{193}
\ttl@stoptoc {default@6}
\ttl@starttoc {default@7}
\contentsline {section}{\numberline {7.1}Defining Abstract Data Types}{194}
\contentsline {subsection}{\numberline {7.1.1}Designing the Sales\_data Class}{194}
\contentsline {paragraph}{Using the Revised Sales\_data Class}{195}
\contentsline {subsection}{\numberline {7.1.2}Designing the revised Sales\_data Class}{195}
\contentsline {paragraph}{Defining Member Functions}{196}
\contentsline {paragraph}{Introducing this}{196}
\contentsline {paragraph}{Introducing const Member Functions}{197}
\contentsline {paragraph}{Class Scope and Member Functions}{197}
\contentsline {paragraph}{Defining a Member Function outside the Class}{197}
\contentsline {paragraph}{Defining a Function to Return “This” Object}{198}
\contentsline {subsection}{\numberline {7.1.3}Defining Nonmember Class-Related Functions}{198}
\contentsline {paragraph}{Defining the read and print Functions}{199}
\contentsline {paragraph}{Defining the add Function}{199}
\contentsline {subsection}{\numberline {7.1.4}Constructors}{199}
\contentsline {paragraph}{The Synthesized Default Constructor}{200}
\contentsline {paragraph}{Some Classes Cannot Rely on the Synthesized Default Constructor}{200}
\contentsline {paragraph}{Defining the Sales\texttt {\_}data Constructors}{201}
\contentsline {paragraph}{What \texttt {=} default Means}{201}
\contentsline {paragraph}{Constructor Initializer List}{201}
\contentsline {paragraph}{Defining a Constructor outside the Class Body}{202}
\contentsline {subsection}{\numberline {7.1.5}Copy, Assignment, and Destruction}{203}
\contentsline {paragraph}{Some Classes Cannot Rely on the Synthesized Versions}{203}
\contentsline {section}{\numberline {7.2}Access Control and Encapsulation}{203}
\contentsline {paragraph}{Using the class or struct Keyword}{204}
\contentsline {subsection}{\numberline {7.2.1}Friends}{204}
\contentsline {paragraph}{Declarations for Friends}{205}
\contentsline {section}{\numberline {7.3}Additional Class Features}{206}
\contentsline {subsection}{\numberline {7.3.1}Class Members Revisited}{206}
\contentsline {paragraph}{Defining a Type Member}{206}
\contentsline {paragraph}{Member Functions of class Screen}{207}
\contentsline {paragraph}{Making Members inline}{207}
\contentsline {paragraph}{Overloading Member Functions}{208}
\contentsline {paragraph}{mutable Data Members}{208}
\contentsline {paragraph}{Initializers for Data Members of Class Type}{208}
\contentsline {subsection}{\numberline {7.3.2}Functions That Return *this}{209}
\contentsline {paragraph}{Returning \texttt {*}this from a const Member Function}{209}
\contentsline {paragraph}{Overloading Based on const}{210}
\contentsline {subsection}{\numberline {7.3.3}Class Types}{211}
\contentsline {paragraph}{Class Declarations}{212}
\contentsline {subsection}{\numberline {7.3.4}Friendship Revisited}{212}
\contentsline {paragraph}{Friendship between Classes}{212}
\contentsline {paragraph}{Making A Member Function a Friend}{213}
\contentsline {paragraph}{Overloaded Functions and Friendship}{213}
\contentsline {paragraph}{Friend Declarations and Scope}{214}
\contentsline {section}{\numberline {7.4}Class Scope}{214}
\contentsline {paragraph}{Scope and Members Defined outside the Class}{214}
\contentsline {subsection}{\numberline {7.4.1}Name Lookup and Class Scope}{215}
\contentsline {paragraph}{Name Lookup for Class Member Declarations}{216}
\contentsline {paragraph}{Type Names Are Special}{216}
\contentsline {paragraph}{Normal Block-Scope Name Lookup inside Member Definitions}{216}
\contentsline {paragraph}{After Class Scope, Look in the Surrounding Scope}{217}
\contentsline {paragraph}{Names Are Resolved Where They Appear within a File}{218}
\contentsline {section}{\numberline {7.5}Constructors Revisited}{218}
\contentsline {subsection}{\numberline {7.5.1}Constructor Initializer List}{219}
\contentsline {paragraph}{Constructor Initializers Are Sometimes Required}{219}
\contentsline {paragraph}{Order of Member Initialization}{220}
\contentsline {paragraph}{Default Arguments and Constructors}{220}
\contentsline {subsection}{\numberline {7.5.2}Delegating Constructors}{221}
\contentsline {subsection}{\numberline {7.5.3}The Role of the Default Constructor}{222}
\contentsline {paragraph}{Using the Default Constructor}{223}
\contentsline {subsection}{\numberline {7.5.4}Implicit Class-Type Conversions}{224}
\contentsline {paragraph}{Only One Class-Type Conversion Is Allowed}{224}
\contentsline {paragraph}{Class-Type Conversions Are Not Always Useful}{224}
\contentsline {paragraph}{Suppressing Implicit Conversions Defined by Constructors}{224}
\contentsline {paragraph}{explicit Constructors Can Be Used Only for Direct Initialization}{225}
\contentsline {paragraph}{Explicitly Using Constructors for Conversions}{225}
\contentsline {paragraph}{Library Classes with explicit Constructors}{225}
\contentsline {subsection}{\numberline {7.5.5}Aggregate Classes}{226}
\contentsline {subsection}{\numberline {7.5.6}Literal Classes}{227}
\contentsline {paragraph}{constexpr Constructors}{227}
\contentsline {section}{\numberline {7.6}static Class Members}{228}
\contentsline {paragraph}{Declaring static Members}{228}
\contentsline {paragraph}{Using a Class static Member}{228}
\contentsline {paragraph}{Defining static Members}{229}
\contentsline {paragraph}{In-Class Initialization of static Data Members}{229}
\contentsline {paragraph}{static Members Can Be Used in Ways Ordinary Members Can’t}{230}
\contentsline {section}{Chapter Summary}{232}
\contentsline {section}{Defined Terms}{232}
\ttl@stoptoc {default@7}
\ttl@stoptoc {parts@1}
\contentsline {part}{II\hspace {1em}The C++ Library}{234}
\ttl@stoptoc {parts@1}
\ttl@starttoc {parts@2}
\contentsline {chapter}{\numberline {8}The IO Library}{235}
\ttl@stoptoc {default@7}
\ttl@starttoc {default@8}
\contentsline {section}{\numberline {8.1}The IO Classes}{236}
\contentsline {paragraph}{Relationships among the IO Types}{236}
\contentsline {subsection}{\numberline {8.1.1}No Copy or Assign for IO Objects}{237}
\contentsline {subsection}{\numberline {8.1.2}Condition States}{237}
\contentsline {paragraph}{Interrogating the State of a Stream}{238}
\contentsline {paragraph}{Managing the Condition State}{239}
\contentsline {subsection}{\numberline {8.1.3}Managing the Output Buffer}{240}
\contentsline {paragraph}{Flushing the Output Buffer}{240}
\contentsline {paragraph}{The unitbuf Manipulator}{240}
\contentsline {paragraph}{Tying Input and Output Streams Together}{240}
\contentsline {section}{\numberline {8.2}File Input and Output}{241}
\contentsline {subsection}{\numberline {8.2.1}Using File Stream Objects}{242}
\contentsline {paragraph}{Using an fstream in Place of an iostream\texttt {\&}}{242}
\contentsline {paragraph}{The open and close Members}{243}
\contentsline {paragraph}{Automatic Construction and Destruction}{243}
\contentsline {subsection}{\numberline {8.2.2}File Modes}{244}
\contentsline {paragraph}{Opening a File in out Mode Discards Existing Data}{244}
\contentsline {paragraph}{File Mode Is Determined Each Time open Is Called}{245}
\contentsline {section}{\numberline {8.3}string Streams}{245}
\contentsline {subsection}{\numberline {8.3.1}Using an istringstream}{245}
\contentsline {subsection}{\numberline {8.3.2}Using ostringstreams}{246}
\contentsline {section}{Chapter Summary}{248}
\contentsline {section}{Defined Terms}{248}
\ttl@stoptoc {default@8}
\contentsline {chapter}{\numberline {9}Sequential Containers}{249}
\ttl@stoptoc {default@8}
\ttl@starttoc {default@9}
\contentsline {section}{\numberline {9.1}Overview of the Sequential Containers}{250}
\contentsline {paragraph}{Deciding Which Sequential Container to Use}{251}
\contentsline {section}{\numberline {9.2}Container Library Overview}{252}
\contentsline {paragraph}{Constraints on Types That a Container Can Hold}{253}
\contentsline {subsection}{\numberline {9.2.1}Iterators}{253}
\contentsline {paragraph}{Iterator Ranges}{253}
\contentsline {paragraph}{Programming Implications of Using Left-Inclusive Ranges}{254}
\contentsline {subsection}{\numberline {9.2.2}Container Type Members}{254}
\contentsline {subsection}{\numberline {9.2.3}begin and end Members}{254}
\contentsline {subsection}{\numberline {9.2.4}Defining and Initializing a Container}{254}
\contentsline {paragraph}{Initializing a Container as a Copy of Another Container}{255}
\contentsline {paragraph}{List Initialization}{255}
\contentsline {paragraph}{Sequential Container Size-Related Constructors}{255}
\contentsline {paragraph}{Library \texttt {array}s Have Fixed Size}{255}
\contentsline {subsection}{\numberline {9.2.5}Assignment and swap}{255}
\contentsline {subsection}{\numberline {9.2.6}Container Size Operations}{255}
\contentsline {subsection}{\numberline {9.2.7}Relational Operators}{255}
\contentsline {section}{\numberline {9.3}Sequential Container Operations}{255}
\contentsline {subsection}{\numberline {9.3.1}Adding Elements to a Sequential Container}{255}
\contentsline {subsection}{\numberline {9.3.2}Accessing Elements}{255}
\contentsline {subsection}{\numberline {9.3.3}Erasing Elements}{255}
\contentsline {subsection}{\numberline {9.3.4}Specialized forward\_list Operations}{255}
\contentsline {subsection}{\numberline {9.3.5}Resizing a Container}{255}
\contentsline {subsection}{\numberline {9.3.6}Container Operations May Invalidate Iterators}{255}
\contentsline {section}{\numberline {9.4}How a vector Grows}{255}
\contentsline {section}{\numberline {9.5}Additional string Operations}{255}
\contentsline {subsection}{\numberline {9.5.1}Other Ways to Construct strings}{255}
\contentsline {subsection}{\numberline {9.5.2}Other Ways to Change a string}{255}
\contentsline {subsection}{\numberline {9.5.3}string Search Operations}{255}
\contentsline {subsection}{\numberline {9.5.4}The compare Functions}{255}
\contentsline {subsection}{\numberline {9.5.5}Numeric Conversions}{255}
\contentsline {section}{\numberline {9.6}Container Adaptors}{255}
\contentsline {section}{Chapter Summary}{256}
\contentsline {section}{Defined Terms}{256}
\ttl@stoptoc {default@9}
\contentsline {chapter}{\numberline {10}Generic Algorithms}{257}
\ttl@stoptoc {default@9}
\ttl@starttoc {default@10}
\contentsline {section}{\numberline {10.1}Overview}{258}
\contentsline {section}{\numberline {10.2}A First Look at the Algorithms}{258}
\contentsline {subsection}{\numberline {10.2.1}Read-Only Algorithms}{258}
\contentsline {subsection}{\numberline {10.2.2}Algorithms That Write Container Elements}{258}
\contentsline {subsection}{\numberline {10.2.3}Algorithms That Reorder Container Elements}{258}
\contentsline {section}{\numberline {10.3}Customizing Operations}{258}
\contentsline {subsection}{\numberline {10.3.1}Passing a Function to an Algorithm}{258}
\contentsline {subsection}{\numberline {10.3.2}Lambda Expressions}{258}
\contentsline {subsection}{\numberline {10.3.3}Lambda Captures and Returns}{258}
\contentsline {subsection}{\numberline {10.3.4}Binding Arguments}{258}
\contentsline {section}{\numberline {10.4}Revisiting Iterators}{258}
\contentsline {subsection}{\numberline {10.4.1}Insert Iterators}{258}
\contentsline {subsection}{\numberline {10.4.2}iostream Iterators}{258}
\contentsline {subsection}{\numberline {10.4.3}Reverse Iterators}{258}
\contentsline {section}{\numberline {10.5}Structure of Generic Algorithms}{258}
\contentsline {subsection}{\numberline {10.5.1}The Five Iterator Categories}{258}
\contentsline {subsection}{\numberline {10.5.2}Algorithm Parameter Patterns}{258}
\contentsline {subsection}{\numberline {10.5.3}Algorithm Naming Conventions}{258}
\contentsline {section}{\numberline {10.6}Container-Specific Algorithms}{258}
\contentsline {section}{Chapter Summary}{259}
\contentsline {section}{Defined Terms}{259}
\ttl@stoptoc {default@10}
\contentsline {chapter}{\numberline {11}Associative Containers}{260}
\ttl@stoptoc {default@10}
\ttl@starttoc {default@11}
\contentsline {section}{\numberline {11.1}Using an Associative Container}{260}
\contentsline {section}{\numberline {11.2}Overview of the Associative Containers}{260}
\contentsline {subsection}{\numberline {11.2.1}Defining an Associative Container}{260}
\contentsline {paragraph}{Initializing a multimap or multiset}{260}
\contentsline {subsection}{\numberline {11.2.2}Requirements on Key Type}{260}
\contentsline {paragraph}{Key Types for Ordered Containers}{260}
\contentsline {paragraph}{Using a Comparison Function for the Key Type}{260}
\contentsline {subsection}{\numberline {11.2.3}The pair Type}{260}
\contentsline {section}{\numberline {11.3}Operations on Associative Containers}{260}
\contentsline {subsection}{\numberline {11.3.1}Associative Container Iterators}{260}
\contentsline {subsection}{\numberline {11.3.2}Adding Elements}{260}
\contentsline {subsection}{\numberline {11.3.3}Erasing Elements}{260}
\contentsline {subsection}{\numberline {11.3.4}Subscripting a map}{260}
\contentsline {subsection}{\numberline {11.3.5}Accessing Elements}{260}
\contentsline {subsection}{\numberline {11.3.6}A Word Transformation Map}{261}
\contentsline {section}{\numberline {11.4}The Unordered Containers}{261}
\contentsline {paragraph}{Using an Unordered Container}{261}
\contentsline {paragraph}{Managing the Buckets}{261}
\contentsline {paragraph}{Requirements on Key Type for Unordered Containers}{261}
\contentsline {section}{Chapter Summary}{262}
\contentsline {section}{Defined Terms}{262}
\ttl@stoptoc {default@11}
\contentsline {chapter}{\numberline {12}Dynamic Memory}{263}
\ttl@stoptoc {default@11}
\ttl@starttoc {default@12}
\contentsline {section}{\numberline {12.1}Dynamic Memory and Smart Pointers}{264}
\contentsline {subsection}{\numberline {12.1.1}The shared\texttt {\_}ptr Class}{264}
\contentsline {subsection}{\numberline {12.1.2}Managing Memory Directly}{264}
\contentsline {paragraph}{Using new to Dynamically Allocate and Initialize Objects}{264}
\contentsline {paragraph}{Dynamically Allocated const Objects}{264}
\contentsline {paragraph}{Memory Exhaustion}{264}
\contentsline {paragraph}{Freeing Dynamic Memory}{264}
\contentsline {paragraph}{Pointer Values and delete}{264}
\contentsline {paragraph}{Dynamically Allocated Objects Exist until They Are Freed}{264}
\contentsline {paragraph}{Resetting the Value of a Pointer after a delete ...}{264}
\contentsline {paragraph}{...Provides Only Limited Protection}{264}
\contentsline {subsection}{\numberline {12.1.3}Using shared\texttt {\_}ptr with new}{264}
\contentsline {subsection}{\numberline {12.1.4}Smart Pointers and Exceptions}{264}
\contentsline {subsection}{\numberline {12.1.5}unique\texttt {\_}ptr}{264}
\contentsline {subsection}{\numberline {12.1.6}weak\texttt {\_}ptr}{264}
\contentsline {section}{\numberline {12.2}Dynamic Arrays}{264}
\contentsline {subsection}{\numberline {12.2.1}new and Arrays}{264}
\contentsline {subsection}{\numberline {12.2.2}The allocator Class}{264}
\contentsline {section}{\numberline {12.3}Using the Library: A Text-Query Program}{264}
\contentsline {subsection}{\numberline {12.3.1}Design of the Query Program}{264}
\contentsline {subsection}{\numberline {12.3.2}Defining the Query Program Classes}{264}
\contentsline {section}{Chapter Summary}{265}
\contentsline {section}{Defined Terms}{265}
\ttl@stoptoc {default@12}
\contentsline {part}{III\hspace {1em}Tools for Class Authors}{266}
\ttl@stoptoc {parts@2}
\ttl@starttoc {parts@3}
\contentsline {chapter}{\numberline {13}Copy Control}{267}
\ttl@stoptoc {default@12}
\ttl@starttoc {default@13}
\contentsline {section}{\numberline {13.1}Copy, Assign, and Destroy}{268}
\contentsline {subsection}{\numberline {13.1.1}The Copy Constructor}{268}
\contentsline {paragraph}{The Synthesized Copy Constructor}{268}
\contentsline {subsection}{\numberline {13.1.2}The Copy-Assignment Operator}{268}
\contentsline {paragraph}{Introducing Overloaded Assignment}{268}
\contentsline {paragraph}{The Synthesized Copy-Assignment Operator}{268}
\contentsline {subsection}{\numberline {13.1.3}The Destructor}{268}
\contentsline {paragraph}{What a Destructor Does}{268}
\contentsline {paragraph}{When a Destructor Is Called}{268}
\contentsline {paragraph}{The Synthesized Destructor}{269}
\contentsline {subsection}{\numberline {13.1.4}The Rule of Three/Five/Zero}{269}
\contentsline {paragraph}{Rule of three}{269}
\contentsline {paragraph}{Rule of five}{270}
\contentsline {paragraph}{Rule of zero}{270}
\contentsline {paragraph}{Classes That Need Destructors Need Copy and Assignment}{271}
\contentsline {paragraph}{Classes That Need Copy Need Assignment, and Vice Versa}{272}
\contentsline {subsection}{\numberline {13.1.5}Using = default}{273}
\contentsline {subsection}{\numberline {13.1.6}Preventing Copies}{273}
\contentsline {paragraph}{Defining a Function as Deleted}{273}
\contentsline {paragraph}{The Destructor Should Not be a Deleted Member}{273}
\contentsline {paragraph}{The Copy-Control Members May Be Synthesized as Deleted}{273}
\contentsline {paragraph}{private Copy Control}{273}
\contentsline {section}{\numberline {13.2}Copy Control and Resource Management}{273}
\contentsline {subsection}{\numberline {13.2.1}Classes That Act Like Values}{273}
\contentsline {subsection}{\numberline {13.2.2}Defining Classes That Act Like Pointers}{273}
\contentsline {section}{\numberline {13.3}Swap}{273}
\contentsline {section}{\numberline {13.4}A Copy-Control Example}{273}
\contentsline {section}{\numberline {13.5}Classes That Manage Dynamic Memory}{273}
\contentsline {section}{\numberline {13.6}Moving Objects}{273}
\contentsline {subsection}{\numberline {13.6.1}Rvalue References}{273}
\contentsline {paragraph}{Lvalues Persist; Rvalues Are Ephemeral}{273}
\contentsline {paragraph}{Variables Are Lvalues}{273}
\contentsline {paragraph}{The Library move Function}{273}
\contentsline {subsection}{\numberline {13.6.2}Move Constructor and Move Assignment}{273}
\contentsline {paragraph}{Move Operations, Library Containers, and Exceptions}{273}
\contentsline {paragraph}{Move-Assignment Operator}{273}
\contentsline {paragraph}{A Moved-from Object Must Be Destructible}{273}
\contentsline {paragraph}{The Synthesized Move Operations}{273}
\contentsline {paragraph}{Rvalues Are Moved, Lvalues Are Copied ...}{273}
\contentsline {paragraph}{...But Rvalues Are Copied If There Is No Move Constructor}{273}
\contentsline {paragraph}{Copy-and-Swap Assignment Operators and Move}{273}
\contentsline {paragraph}{Move Operations for the Message Class}{273}
\contentsline {paragraph}{Move Iterators}{273}
\contentsline {subsection}{\numberline {13.6.3}Rvalue References and Member Functions}{273}
\contentsline {paragraph}{Rvalue and Lvalue Reference Member Functions}{273}
\contentsline {section}{Chapter Summary}{274}
\contentsline {section}{Defined Terms}{274}
\ttl@stoptoc {default@13}
\contentsline {chapter}{\numberline {14}Overloaded Operations and Conversions}{275}
\ttl@stoptoc {default@13}
\ttl@starttoc {default@14}
\contentsline {section}{\numberline {14.1}Basic Concepts}{276}
\contentsline {paragraph}{Choosing Member or Nonmember Implementation}{276}
\contentsline {section}{\numberline {14.2}Input and Output Operators}{276}
\contentsline {subsection}{\numberline {14.2.1}Overloading the Output Operator <<}{276}
\contentsline {subsection}{\numberline {14.2.2}Overloading the Input Operator >>}{276}
\contentsline {section}{\numberline {14.3}Arithmetic and Relational Operators}{276}
\contentsline {subsection}{\numberline {14.3.1}Equality Operators}{276}
\contentsline {subsection}{\numberline {14.3.2}Relational Operators}{276}
\contentsline {section}{\numberline {14.4}Assignment Operators}{276}
\contentsline {section}{\numberline {14.5}Subscript Operator}{276}
\contentsline {section}{\numberline {14.6}Increment and Decrement Operators}{276}
\contentsline {section}{\numberline {14.7}Member Access Operators}{276}
\contentsline {section}{\numberline {14.8}Function-Call Operator}{276}
\contentsline {subsection}{\numberline {14.8.1}Lambdas Are Function Objects}{276}
\contentsline {subsection}{\numberline {14.8.2}Library-Defined Function Objects}{276}
\contentsline {subsection}{\numberline {14.8.3}Callable Objects and function}{276}
\contentsline {section}{\numberline {14.9}Overloading, Conversions, and Operators}{276}
\contentsline {subsection}{\numberline {14.9.1}Conversion Operators}{276}
\contentsline {subsection}{\numberline {14.9.2}Avoiding Ambiguous Conversions}{276}
\contentsline {subsection}{\numberline {14.9.3}Function Matching and Overloaded Operators}{276}
\contentsline {section}{Chapter Summary}{277}
\contentsline {section}{Defined Terms}{277}
\ttl@stoptoc {default@14}
\contentsline {chapter}{\numberline {15}Object-Oriented Programming}{278}
\ttl@stoptoc {default@14}
\ttl@starttoc {default@15}
\contentsline {section}{\numberline {15.1}OOP: An Overview}{279}
\contentsline {paragraph}{Inheritance}{279}
\contentsline {paragraph}{Dynamic Binding}{279}
\contentsline {section}{\numberline {15.2}Defining Base and Derived Classes}{280}
\contentsline {subsection}{\numberline {15.2.1}Defining a Base Class}{280}
\contentsline {paragraph}{Member Functions and Inheritance}{281}
\contentsline {paragraph}{Access Control and Inheritance}{281}
\contentsline {subsection}{\numberline {15.2.2}Defining a Derived Class}{281}
\contentsline {paragraph}{Virtual Functions in the Derived Class}{282}
\contentsline {paragraph}{Derived-Class Objects and the Derived-to-Base Conversion}{282}
\contentsline {paragraph}{Derived-Class Constructors}{283}
\contentsline {paragraph}{Using Members of the Base Class from the Derived Class}{283}
\contentsline {paragraph}{Inheritance and static Members}{284}
\contentsline {paragraph}{Declarations of Derived Classes}{284}
\contentsline {paragraph}{Classes Used as a Base Class}{284}
\contentsline {paragraph}{Preventing Inheritance}{285}
\contentsline {subsection}{\numberline {15.2.3}Conversions and Inheritance}{285}
\contentsline {paragraph}{Static Type and Dynamic Type}{285}
\contentsline {paragraph}{There Is No Implicit Conversion from Base to Derived ...}{286}
\contentsline {paragraph}{...and No Conversion between Objects}{286}
\contentsline {section}{\numberline {15.3}Virtual Functions}{287}
\contentsline {paragraph}{Calls to Virtual Functions May Be Resolved at Run Time}{287}
\contentsline {paragraph}{Virtual Functions in a Derived Class}{288}
\contentsline {paragraph}{The final and override Specifiers}{288}
\contentsline {paragraph}{Virtual Functions and Default Arguments}{289}
\contentsline {paragraph}{Circumventing the Virtual Mechanism}{289}
\contentsline {section}{\numberline {15.4}Abstract Base Classes}{291}
\contentsline {paragraph}{Pure Virtual Functions}{291}
\contentsline {paragraph}{Classes with Pure Virtuals Are Abstract Base Classes}{291}
\contentsline {paragraph}{A Derived Class Constructor Initializes Its Direct Base Class Only}{292}
\contentsline {section}{\numberline {15.5}Access Control and Inheritance}{292}
\contentsline {paragraph}{protected Members}{292}
\contentsline {paragraph}{public, private, and protected Inheritance}{293}
\contentsline {paragraph}{Accessibility of Derived-to-Base Conversion}{294}
\contentsline {paragraph}{Friendship and Inheritance}{295}
\contentsline {paragraph}{Exempting Individual Members}{296}
\contentsline {paragraph}{Default Inheritance Protection Levels}{296}
\contentsline {section}{\numberline {15.6}Class Scope under Inheritance}{297}
\contentsline {paragraph}{Name Lookup Happens at Compile Time}{297}
\contentsline {paragraph}{Name Collisions and Inheritance}{298}
\contentsline {paragraph}{Using the Scope Operator to Use Hidden Members}{298}
\contentsline {paragraph}{As Usual, Name Lookup Happens before Type Checking}{299}
\contentsline {paragraph}{Virtual Functions and Scope}{299}
\contentsline {paragraph}{Calling a Hidden Virtual through the Base Class}{300}
\contentsline {paragraph}{Overriding Overloaded Functions}{300}
\contentsline {section}{\numberline {15.7}Constructors and Copy Control}{301}
\contentsline {subsection}{\numberline {15.7.1}Virtual Destructors}{301}
\contentsline {paragraph}{Virtual Destructors Turn Off Synthesized Move}{302}
\contentsline {subsection}{\numberline {15.7.2}Synthesized Copy Control and Inheritance}{302}
\contentsline {paragraph}{Base Classes and Deleted Copy Control in the Derived}{302}
\contentsline {paragraph}{Move Operations and Inheritance}{303}
\contentsline {subsection}{\numberline {15.7.3}Derived-Class Copy-Control Members}{303}
\contentsline {paragraph}{Defining a Derived Copy or Move Constructor}{304}
\contentsline {paragraph}{Derived-Class Assignment Operator}{304}
\contentsline {paragraph}{Derived-Class Destructor}{305}
\contentsline {paragraph}{Calls to Virtuals in Constructors and Destructors}{305}
\contentsline {subsection}{\numberline {15.7.4}Inherited Constructors}{305}
\contentsline {paragraph}{Characteristics of an Inherited Constructor}{306}
\contentsline {section}{\numberline {15.8}Containers and Inheritance}{306}
\contentsline {paragraph}{Put (Smart) Pointers, Not Objects, in Containers}{307}
\contentsline {subsection}{\numberline {15.8.1}Writing a Basket Class}{307}
\contentsline {paragraph}{Defining the Members of Basket}{308}
\contentsline {paragraph}{Hiding the Pointers}{308}
\contentsline {paragraph}{Simulating Virtual Copy}{309}
\contentsline {section}{\numberline {15.9}Text Queries Revisited}{310}
\contentsline {subsection}{\numberline {15.9.1}An Object-Oriented Solution}{311}
\contentsline {subsection}{\numberline {15.9.2}The Query\texttt {\_}base and Query Classes}{311}
\contentsline {subsection}{\numberline {15.9.3}The Derived Classes}{311}
\contentsline {subsection}{\numberline {15.9.4}The eval Functions}{311}
\contentsline {section}{Chapter Summary}{312}
\contentsline {section}{Defined Terms}{312}
\ttl@stoptoc {default@15}
\contentsline {chapter}{\numberline {16}Templates and Generic Programming}{313}
\ttl@stoptoc {default@15}
\ttl@starttoc {default@16}
\contentsline {section}{\numberline {16.1}Defining a Template}{314}
\contentsline {subsection}{\numberline {16.1.1}Function Templates}{314}
\contentsline {paragraph}{Instantiating a Function Template}{314}
\contentsline {paragraph}{Template Type Parameters}{314}
\contentsline {paragraph}{Nontype Template Parameters}{314}
\contentsline {paragraph}{inline and constexpr Function Templates}{314}
\contentsline {paragraph}{Writing Type-Independent Code}{314}
\contentsline {paragraph}{Template Compilation}{314}
\contentsline {paragraph}{Compilation Errors Are Mostly Reported during Instantiation}{314}
\contentsline {subsection}{\numberline {16.1.2}Class Templates}{314}
\contentsline {subsection}{\numberline {16.1.3}Template Parameters}{314}
\contentsline {subsection}{\numberline {16.1.4}Member Templates}{314}
\contentsline {subsection}{\numberline {16.1.5}Controlling Instantiations}{314}
\contentsline {subsection}{\numberline {16.1.6}Efficiency and Flexibility}{314}
\contentsline {section}{\numberline {16.2}Template Argument Deduction}{314}
\contentsline {subsection}{\numberline {16.2.1}Conversions and Template Type Parameters}{314}
\contentsline {subsection}{\numberline {16.2.2}Function-Template Explicit Arguments}{314}
\contentsline {subsection}{\numberline {16.2.3}Trailing Return Types and Type Transformation}{314}
\contentsline {subsection}{\numberline {16.2.4}Function Pointers and Argument Deduction}{314}
\contentsline {subsection}{\numberline {16.2.5}Template Argument Deduction and References}{314}
\contentsline {subsection}{\numberline {16.2.6}Understanding std::move}{314}
\contentsline {subsection}{\numberline {16.2.7}Forwarding}{314}
\contentsline {section}{\numberline {16.3}Overloading and Templates}{314}
\contentsline {section}{\numberline {16.4}Variadic Templates}{314}
\contentsline {subsection}{\numberline {16.4.1}Writing a Variadic Function Template}{314}
\contentsline {subsection}{\numberline {16.4.2}Pack Expansion}{314}
\contentsline {subsection}{\numberline {16.4.3}Forwarding Parameter Packs}{314}
\contentsline {section}{\numberline {16.5}Template Specializations}{314}
\contentsline {section}{Chapter Summary}{315}
\contentsline {section}{Defined Terms}{315}
\ttl@stoptoc {default@16}
\contentsline {part}{IV\hspace {1em}Advanced Topics}{316}
\ttl@stoptoc {parts@3}
\ttl@starttoc {parts@4}
\contentsline {chapter}{\numberline {17}Specialized Library Facilities}{317}
\ttl@stoptoc {default@16}
\ttl@starttoc {default@17}
\contentsline {section}{\numberline {17.1}The tuple Type}{318}
\contentsline {subsection}{\numberline {17.1.1}Defining and Initializing tuples}{318}
\contentsline {subsection}{\numberline {17.1.2}Using a tuple to Return Multiple Values}{318}
\contentsline {section}{\numberline {17.2}The bitset Type}{318}
\contentsline {subsection}{\numberline {17.2.1}Defining and Initializing bitsets}{318}
\contentsline {subsection}{\numberline {17.2.2}Operations on bitsets}{318}
\contentsline {section}{\numberline {17.3}Regular Expressions}{318}
\contentsline {subsection}{\numberline {17.3.1}Using the Regular Expression Library}{318}
\contentsline {subsection}{\numberline {17.3.2}The Match and Regex Iterator Types}{318}
\contentsline {subsection}{\numberline {17.3.3}Using Subexpressions}{318}
\contentsline {subsection}{\numberline {17.3.4}Using regex\texttt {\_}replace}{318}
\contentsline {section}{\numberline {17.4}Random Numbers}{318}
\contentsline {subsection}{\numberline {17.4.1}Random-Number Engines and Distribution}{318}
\contentsline {subsection}{\numberline {17.4.2}Other Kinds of Distributions}{318}
\contentsline {section}{\numberline {17.5}The IO Library Revisited}{318}
\contentsline {subsection}{\numberline {17.5.1}Formatted Input and Output}{318}
\contentsline {subsection}{\numberline {17.5.2}Unformatted Input/Output Operations}{318}
\contentsline {subsection}{\numberline {17.5.3}Random Access to a Stream}{318}
\contentsline {paragraph}{Seek and Tell Functions}{318}
\contentsline {paragraph}{There Is Only One Marker}{318}
\contentsline {paragraph}{Repositioning the Marker}{318}
\contentsline {paragraph}{Accessing the Marker}{318}
\contentsline {paragraph}{Reading and Writing to the Same File}{318}
\contentsline {section}{Chapter Summary}{319}
\contentsline {section}{Defined Terms}{319}
\ttl@stoptoc {default@17}
\contentsline {chapter}{\numberline {18}Tools for Large Programs}{320}
\ttl@stoptoc {default@17}
\ttl@starttoc {default@18}
\contentsline {section}{\numberline {18.1}Exception Handling}{320}
\contentsline {subsection}{\numberline {18.1.1}Throwing an Exception}{320}
\contentsline {subsection}{\numberline {18.1.2}Catching an Exception}{320}
\contentsline {subsection}{\numberline {18.1.3}Function try Blocks and Constructors}{320}
\contentsline {subsection}{\numberline {18.1.4}The noexcept Exception Specification}{320}
\contentsline {subsection}{\numberline {18.1.5}Exception Class Hierarchies}{320}
\contentsline {section}{\numberline {18.2}Namespaces}{320}
\contentsline {subsection}{\numberline {18.2.1}Namespace Definitions}{320}
\contentsline {subsection}{\numberline {18.2.2}Using Namespace Members}{320}
\contentsline {subsection}{\numberline {18.2.3}Classes, Namespaces, and Scope}{320}
\contentsline {subsection}{\numberline {18.2.4}Overloading and Namespaces}{320}
\contentsline {section}{\numberline {18.3}Multiple and Virtual Inheritance}{320}
\contentsline {subsection}{\numberline {18.3.1}Multiple Inheritance}{320}
\contentsline {subsection}{\numberline {18.3.2}Multiple Inheritance}{320}
\contentsline {subsection}{\numberline {18.3.3}Class Scope under Multiple Inheritance}{320}
\contentsline {subsection}{\numberline {18.3.4}Virtual Inheritance}{320}
\contentsline {subsection}{\numberline {18.3.5}Constructors and Virtual Inheritance}{320}
\contentsline {section}{Chapter Summary}{321}
\contentsline {section}{Defined Terms}{321}
\ttl@stoptoc {default@18}
\contentsline {chapter}{\numberline {19}Specialized Tools and Techniques}{322}
\ttl@stoptoc {default@18}
\ttl@starttoc {default@19}
\contentsline {section}{\numberline {19.1}Controlling Memory Allocation}{323}
\contentsline {subsection}{\numberline {19.1.1}Overloading new and delete}{323}
\contentsline {subsection}{\numberline {19.1.2}Placement new Expressions}{323}
\contentsline {section}{\numberline {19.2}Run-Time Type Identification}{323}
\contentsline {subsection}{\numberline {19.2.1}The dynamic\texttt {\_}cast Operator}{323}
\contentsline {subsection}{\numberline {19.2.2}The typeid Operator}{323}
\contentsline {subsection}{\numberline {19.2.3}Using RTTI}{323}
\contentsline {subsection}{\numberline {19.2.4}The type\texttt {\_}info Class}{323}
\contentsline {section}{\numberline {19.3}Enumerations}{323}
\contentsline {section}{\numberline {19.4}Pointer to Class Member}{323}
\contentsline {subsection}{\numberline {19.4.1}Pointers to Data Members}{323}
\contentsline {subsection}{\numberline {19.4.2}Pointers to Member Functions}{323}
\contentsline {subsection}{\numberline {19.4.3}Using Member Functions as Callable Objects}{323}
\contentsline {section}{\numberline {19.5}Nested Classes}{323}
\contentsline {section}{\numberline {19.6}union: A Space-Saving Class}{323}
\contentsline {section}{\numberline {19.7}Local Classes}{323}
\contentsline {section}{\numberline {19.8}Inherently Nonportable Features}{323}
\contentsline {subsection}{\numberline {19.8.1}Bit-fields}{323}
\contentsline {subsection}{\numberline {19.8.2}volatile Qualifier}{323}
\contentsline {subsection}{\numberline {19.8.3}Linkage Directives: extern "C"}{323}
\contentsline {section}{Chapter Summary}{324}
\contentsline {section}{Defined Terms}{324}
\ttl@stoptoc {default@19}
\renewcommand *{\chaptername }{\appendixname }
\contentsline {chapter}{\numberline {A}The Library}{325}
\ttl@stoptoc {default@19}
\ttl@starttoc {default@20}
\contentsline {section}{\numberline {A.1}Library Names and Headers}{326}
\contentsline {section}{\numberline {A.2}Brief Tour of the Algorithms}{329}
\contentsline {subsection}{\numberline {A.2.1}Algorithms to Find an Object}{329}
\contentsline {subsection}{\numberline {A.2.2}Other Read-Only Algorithms}{329}
\contentsline {subsection}{\numberline {A.2.3}Binary Search Algorithms}{329}
\contentsline {subsection}{\numberline {A.2.4}Algorithms That Write Container Elements}{329}
\contentsline {subsection}{\numberline {A.2.5}Partitioning and Sorting Algorithms}{329}
\contentsline {subsection}{\numberline {A.2.6}General Reordering Operations}{329}
\contentsline {subsection}{\numberline {A.2.7}Permutation Algorithms}{329}
\contentsline {subsection}{\numberline {A.2.8}Set Algorithms for Sorted Sequences}{329}
\contentsline {subsection}{\numberline {A.2.9}Minimum and Maximum Values}{329}
\contentsline {subsection}{\numberline {A.2.10}Numeric Algorithms}{329}
\contentsline {section}{\numberline {A.3}Random Numbers}{329}
\contentsline {subsection}{\numberline {A.3.1}Random Number Distributions}{329}
\contentsline {subsection}{\numberline {A.3.2}Random Number Engines}{329}
\ttl@stoptoc {default@20}
\contentsline {chapter}{Index}{330}
\contentsfinish 
