% ------------------------------------------------------------------------
% file `C++Primer_en-exercises-62-exercise-body.tex'
%
%     exercise of type `exercises' with id `62'
%
% generated by the `exercises' environment of the
%   `xsim' package v0.8a (2017/05/19)
% from source `C++Primer_en' on 2018/03/12 on line 9939
% ------------------------------------------------------------------------
\begin{question}
Explain each of the following loops. Correct any problems
you detect.
\begin{enumerate}[label=(\alph*)]
^^I\item
\begin{lstlisting}
for (int ix = 0; ix != sz; ++ix) { /* . . . */ }
if (ix != sz)
   // . . .
\end{lstlisting}

^^I\item
\begin{lstlisting}
int ix;
for (ix != sz; ++ix) { /* . . . */ }
\end{lstlisting}

^^I\item
\begin{lstlisting}
for (int ix = 0; ix != sz; ++ix, ++sz) { /* . . . */ }
\end{lstlisting}
\end{enumerate}
\end{question}

\begin{question}
The \verb|while| loop is particularly good at executing while some
condition holds; for example, when we need to read values until end-of-file.
The \verb|for| loop is generally thought of as a step loop: An index steps through
a range of values in a collection. Write an idiomatic use of each loop and
then rewrite each using the other loop construct. If you could use only one
loop, which would you choose? Why?
\end{question}

\begin{question}
Given two \verb|vector|s of \verb|int|s, write a program to determine
whether one \verb|vector| is a prefix of the other. For \verb|vector|s of unequal
length, compare the number of elements of the smaller \verb|vector|. For
example, given the \verb|vector|s containing 0, 1, 1, and 2 and 0, 1, 1, 2, 3, 5,
8, respectively your program should return \verb|true|.
\end{question}
